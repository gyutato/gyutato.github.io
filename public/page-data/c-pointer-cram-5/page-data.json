{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/c-pointer-cram-5/",
    "result": {"data":{"cur":{"id":"d026fe1d-c523-541c-9950-1c536f008a8d","html":"<h2 id=\"️-배열-포인터는-왜-필요한가\" style=\"position:relative;\"><a href=\"#%EF%B8%8F-%EB%B0%B0%EC%97%B4-%ED%8F%AC%EC%9D%B8%ED%84%B0%EB%8A%94-%EC%99%9C-%ED%95%84%EC%9A%94%ED%95%9C%EA%B0%80\" aria-label=\"️ 배열 포인터는 왜 필요한가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🤷‍♀️ 배열 포인터는 왜 필요한가?</h2>\n<p>앞서 우리는 배열 이름, 즉 배열의 첫 번째 원소의 주소가 아니라 <strong>배열 자체의 주소</strong>를 담기 위한 포인터를 생각해보았다. 왜 굳이 이런 포인터가 필요할까? 애초에 베열의 이름이 포인터와 유사한 기능을 (사실 포인터가 맞지만, 그 값을 변경할 수 없는 상수라는 점에서 차이가 있다) 하는데 왜 따로 배열 포인터를 정의하여 사용하는 것일까. 이는 <strong>2차원 이상의 배열</strong>을 가리킬 때 포인터를 통해 배열과 같이 인덱싱(<code class=\"language-text\">[]</code>)을 할 수 있도록 하기 위함이다.</p>\n<p>한 마디로, 포인터를 배열처럼 사용하기 위해서 배열 포인터를 정의하여 사용한다.</p>\n<br/>\n<h3 id=\"1-2차원-배열\" style=\"position:relative;\"><a href=\"#1-2%EC%B0%A8%EC%9B%90-%EB%B0%B0%EC%97%B4\" aria-label=\"1 2차원 배열 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 2차원 배열?</h3>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>2차원 배열을 생각해 보자. 위 경우 <code class=\"language-text\">int a[3]</code> 짜리 배열 2 개가 메모리에 연속적으로 존재하는 것이다. 여기서 <code class=\"language-text\">sizeof</code>를 사용하여 2차원 배열의 열, 행의 개수를 계산할 수 있다:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"전체 크기 : %d \\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 배열의 전체 크기 = 2 * 3 * 4 = 12</span>\n\n  <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"총 열의 개수 : %d \\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// (1차원 배열 한 개의 크기) / (배열 안의 한 요소의 크기) --> 총 열의 개수 = 3</span>\n\n  <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"총 행의 개수 : %d \\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// (배열의 크기 ) / (1차원 배열 한 개의 크기) --> 총 행의 개수 = 2</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>코드 출처: <a href=\"https://modoocode.com/25\">https://modoocode.com/25</a></li>\n</ul>\n<p>여기서, 당연하게도 <code class=\"language-text\">int arr[2][3]</code>은 <code class=\"language-text\">int [2][3]</code> 자료형의 배열이고, 총 6개의 원소들은 전부 <code class=\"language-text\">int</code> 자료형이므로 각 행의 첫 원소를 가리키는 <code class=\"language-text\">arr[0]</code>, <code class=\"language-text\">arr[1]</code>은 모두 암묵적으로 <code class=\"language-text\">int *</code>형으로 변환될 것이다.</p>\n<p>그렇다면, <code class=\"language-text\">arr[0]</code>과 <code class=\"language-text\">arr[1]</code>을 모두 포함하여 <code class=\"language-text\">arr</code> 그 자체는 어떻게 가리킬 수 있을까? 여기서 우리가 실컷 논의한 <strong>배열 포인터</strong>와 이중 포인터가 등장한다.</p>\n<p>우선 위의 질문, <u><code class=\"language-text\">arr[0]</code>과 <code class=\"language-text\">arr[1]</code>을 모두 포함하여 <code class=\"language-text\">arr</code> 그 자체는 어떻게 가리킬 수 있을까?</u>에 대해 ”<code class=\"language-text\">int**</code>로 바로 가리키면 되잖아” 라고 생각한다면, 안타깝게도 틀렸다. 위의 <code class=\"language-text\"> int arr[2][3]</code>을 예시로 생각해 보자:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span>pa <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"pa[1][1] : %d \\n\"</span><span class=\"token punctuation\">,</span> pa<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>배열 <code class=\"language-text\">arr</code>의 첫 번째 원소를 가리키는 이중 포인터 <code class=\"language-text\">pa</code>를 선언해 보았다. 그러면 바로 접근할 수 있을까? 포인터 <code class=\"language-text\">pa</code>가 <code class=\"language-text\">arr</code>배열의 <code class=\"language-text\">[0][[0]</code> 위치를 정확히 가리키기 위해서는 다음 과정을 거쳐야 한다:</p>\n<ul>\n<li><code class=\"language-text\">arr[1][1]</code> = * ( * (<code class=\"language-text\">arr</code> + 1 * <code class=\"language-text\">한 행의 크기</code>) + 1 * (<code class=\"language-text\">행 내부 원소의 크기</code>) )</li>\n</ul>\n<p>우리는 행 내부 원소의 크기는 알고 있다. <code class=\"language-text\">arr[1][1]</code> 은 <code class=\"language-text\">int arr[2][3]</code> 배열의 한 원소이므로, 당연히 <code class=\"language-text\">int</code>형, 즉 4바이트다. 그러면:</p>\n<ul>\n<li><code class=\"language-text\">arr[1][1]</code> = * ( * (<code class=\"language-text\">arr</code> + 1 * <code class=\"language-text\">한 행의 크기</code>) + 1 * 4 )</li>\n</ul>\n<p>다음과 같이 정리할 수 있다. 그러나, 우리는 여전히 <strong>한 행의 크기</strong>를 모른다. 우리는 당연히 <code class=\"language-text\">[3]</code>, 즉 원소 4개가 모여 한 행을 이룬다는 것을 알고 있지만, 포인터 <code class=\"language-text\">pa</code>는 이것을 모른다!</p>\n<p>앞서 포인터를 정의할 때에는 포인터가 접근할 주소와 접근할 크기를 알려주어야 한다고 했다. <strong>접근할 주소는 대입 연산자로 할당</strong>하고, <strong>접근할 크기는 포인터 선언 시 포인터의 자료형으로 넘겨준다</strong>고 말이다.<code class=\"language-text\">int **pa = arr;</code>라는 아까의 선언을 보자. 접근할 주소는 arr, 즉 <code class=\"language-text\">arr[0]</code> (= <code class=\"language-text\">arr[0][0]</code>)을 가리키고 있다. 그리고 <code class=\"language-text\">pa</code>의 자료형은? <code class=\"language-text\">int (*)*</code>다. 즉 ”<code class=\"language-text\">int *</code>형을 가리키는 포인터”이다. 그러면 이 자료형으로 접근할 수 있는 크기는? <strong>포인터이므로 8바이트다.</strong></p>\n<p>그래서 정확히 포인터에게 한 행의 크기인 [3]을 알려주기 위해 <code class=\"language-text\">pa</code>는 <code class=\"language-text\">int (*)[3]</code> 자료형이 되어야 한다. 그러면 4칸을 한 행으로 갖는 배열(<code class=\"language-text\">[3]</code>)이고, 각 칸은 4바이트(<code class=\"language-text\">int</code>)라는 것을 포인터가 정확히 알 수 있다.</p>\n<br/>\n<blockquote>\n<p>🤔 <strong><code class=\"language-text\">arr [2][3]</code>인데 왜 <code class=\"language-text\">int (*)[2][3]</code> 자료형이 아닌 <code class=\"language-text\">int (*)[3]</code> 자료형인가요?</strong><br/><br/>✅ 우리가 1차원 배열, 예를 들어 <code class=\"language-text\">int arr[10];</code>이라는 배열에 포인터로 접근하던 때를 생각해보자. 이 때 포인터는 <code class=\"language-text\">int *</code> 자료형이었지, <code class=\"language-text\">int (*)[10]</code> 자료형이 아니었다. 즉 이 말은 원소가 10개이든, 100개이든 그건 중요하지 않고, <u>포인터 연산</u> 즉 <strong><code class=\"language-text\">pa + {정수}</code> 를 통해 포인터가 뛰어넘어야 할 바이트</strong>만 포인터에게 알려주면 된다는 뜻이다.<br/>그러므로 <code class=\"language-text\">arr [2][3]</code>도 마찬가지로, <code class=\"language-text\">int [3]</code>짜리 배열이라는 사실은 각 원소의 크기와 각 행의 크기를 알려주므로 중요하지만, 그 배열이 총 3개(<code class=\"language-text\">[2]</code>)인지 몇 개인지는 중요하지 않다. 사실 포인터가 배열의 끝을 중요하게 생각하고 알 수 있었다면 <strong>오버플로우</strong> 문제를 지금보다 덜 신경써도 됐을 것이다…</p>\n</blockquote>\n<br/>\n<h2 id=\"-심화-자료형과-포인터\" style=\"position:relative;\"><a href=\"#-%EC%8B%AC%ED%99%94-%EC%9E%90%EB%A3%8C%ED%98%95%EA%B3%BC-%ED%8F%AC%EC%9D%B8%ED%84%B0\" aria-label=\" 심화 자료형과 포인터 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 심화: 자료형과 포인터</h2>\n<p>개인적으로 헷갈리는 부분을 정리했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>pa<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>arr<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>pa<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 에러!</span>\n\n  <span class=\"token keyword\">int</span> newarr<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>newpa<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>newpa<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>arr<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 에러!</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>똑같은 <code class=\"language-text\">int (*)[3]</code> 포인터 <code class=\"language-text\">pa</code>와 <code class=\"language-text\">newpa</code>인데, 1차원 배열을 가리킬 때는 <code class=\"language-text\">&amp;</code>을 붙여야 하고 2차원 배열을 가리킬 때는 반대로 <code class=\"language-text\">&amp;</code>을 붙이면 에러가 난다. 어째서?</p>\n<p>여기서 다시 한번 <strong>배열의 주소값</strong>과 <strong>배열 이름</strong>의 차이를 명확히 정리하고 넘어가려고 한다.</p>\n<ul>\n<li><strong>배열의 주소값</strong>은 배열 그 자체를 가리키는 주소다.</li>\n<li><strong>배열 이름</strong>은 배열의 첫 번째 원소의 주소다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\">  <span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"배열의 주소값: %p\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"배열의 첫 번째 원소의 주소값: %p\"</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 배열의 주소값과 동일하다</span></code></pre></div>\n<p>위와 같이 <code class=\"language-text\">int</code> 원소 10개짜리, 즉 40바이트짜리 배열 <code class=\"language-text\">arr</code>가 있다고 하자. 그러면 당연히 배열의 주소값과 배열의 첫 번째 원소의 주소값은 <strong>동일</strong>하다. 주소값이란 어떤 데이터의 <strong>시작 위치</strong>이기 때문이다. 그러나 포인터에 할당될 때에 이 둘은 완전히 다르다. <code class=\"language-text\">&amp;arr</code>으로 할당하면 배열의 전체 크기, 즉 40바이트만큼 가리키는 <code class=\"language-text\">int (*)[10]</code> 자료형을 넘겨주게 되고, <code class=\"language-text\">arr</code>으로 할당하면 첫 번째 원소의 크기, 즉 4바이트만큼 가리키는 <code class=\"language-text\">int *</code>자료형을 넘겨주게 된다.</p>\n<p>따라서 다시, 위의 코드에서</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>pa<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>arr<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>pa<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 에러!</span></code></pre></div>\n<p>부분은 포인터의 자료형에 맞추어 <code class=\"language-text\">&amp;arr</code>, 즉 배열 전체를 넘겨주어야 한다. <code class=\"language-text\">int (*pa)[3] = arr;</code>의 경우 <code class=\"language-text\">int (*)[3]</code> 자료형인 포인터에 <code class=\"language-text\">int *</code> 자료형인 <code class=\"language-text\">arr</code>을 넘겨주는 꼴이 되어 <code class=\"language-text\">incompatible pointer types</code> 에러를 발생시킨다. 이후 원소에 접근할 때에도 <code class=\"language-text\">(*pa)[1]</code>과 같이 포인터의 값, 즉 <em>배열에 접근하여 원소를 불러와야 한다</em> (<code class=\"language-text\">(*pa)</code>는 그 <code class=\"language-text\">pa</code>의 값을 역참조한다는 뜻으로 <code class=\"language-text\">arr</code>과 같다. 최초 선언 시의 <code class=\"language-text\">(*pa)</code>는 <code class=\"language-text\">배열 포인터 pa</code>라는 뜻이므로, 단순히 포인터로 사용하기 위해서는 그냥 <code class=\"language-text\">pa</code>라고 사용하며, <code class=\"language-text\">(*pa)</code>는 그 <code class=\"language-text\">pa</code>의 값을 역참조한다는 뜻으로 값, 즉 배열 자체에 접근한다). <strong>그러니까 사실 1차원 배열에서 <code class=\"language-text\">(*pa)</code>같은 배열 포인터는 굳이 필요하지 않다.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> newarr<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>newpa<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> newarr<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>newpa<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>newarr<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 에러!</span></code></pre></div>\n<p>반면, 위의 코드는 어떨까. 2차원 배열이므로 우선 배열 전체의 주소를 의미하는 <code class=\"language-text\">&amp;arr</code>의 자료형이 <code class=\"language-text\">int (*)[2][3]</code>이라는 것은 알겠다. 그렇다면, <code class=\"language-text\">arr</code>는? 이 배열의 첫 번째 원소는 <code class=\"language-text\">arr[0]</code>일까, <code class=\"language-text\">arr[0][0]</code>일까? <code class=\"language-text\">newarr</code>는 <strong>배열을 원소로 갖는 배열</strong>이다. 정확히 말하자면 “1차원 원소 두 개를 원소로 갖는 2차원 배열”이다. 그러므로 이 배열의 첫 번째 원소는 <code class=\"language-text\">arr[0]</code>이다. 물론 <code class=\"language-text\">arr[0][0]</code>과 시작 주소는 같다. 하지만 <code class=\"language-text\">arr[0]</code>의 자료형은 <code class=\"language-text\">int (*)[3]</code>이고 <code class=\"language-text\">arr[0][0]</code>의 자료형은 <code class=\"language-text\">int *</code>이다. 그래서 <code class=\"language-text\">newarr</code>의 한 원소, 즉 한 1차원 배열을 가리키려면 <code class=\"language-text\">int (*newpa)[3] = arr;</code>이 맞다.</p>\n<br/>\n<h2 id=\"-진짜-마무리\" style=\"position:relative;\"><a href=\"#-%EC%A7%84%EC%A7%9C-%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-label=\" 진짜 마무리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🙌 진짜 마무리</h2>\n<p>‘배열 포인터’란, 포인터를 통해 배열을 인덱싱하는 것과 동일한 일을 하기 위해 만들어졌다고 했다. 즉, <code class=\"language-text\">{배열 포인터}[1]</code>은 <code class=\"language-text\">{배열}[1]</code>과 같았으면 좋겠다는 이야기다.</p>\n<p>그러니까 위의 코드에서 <code class=\"language-text\">int newarr[2][3] = {{1, 2, 3}, {4, 5, 6}};</code>에 포인터 <code class=\"language-text\">newpa</code>로 접근한다는 것은, <code class=\"language-text\">newarr[1][1]</code>과 <code class=\"language-text\">newpa[1][1]</code>이 같아야 한다는 이야기다.</p>\n<p>즉 <code class=\"language-text\">newpa</code>는 배열 <code class=\"language-text\">newarr</code>를 가리켜야 하는 것은 맞는데, 배열 전체가 아닌 각 원소(1차원 배열)의 크기만큼을 가리키도록 해서 그 내부에도 다시한번 인덱스로 접근할 수 있는… 뭐 그런 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> zippo<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\nExpression    Type            Implicitly converted to  Equivalent expression\n<span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span>    <span class=\"token operator\">--</span><span class=\"token operator\">--</span>            <span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span>  <span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span>\nzippo         <span class=\"token keyword\">int</span> <span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span>      <span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span>               \n<span class=\"token operator\">&amp;</span>zippo        <span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span>       \n<span class=\"token operator\">*</span>zippo        <span class=\"token keyword\">int</span> <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span>         <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>                    zippo<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\nzippo<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>      <span class=\"token keyword\">int</span> <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span>         <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>\n<span class=\"token operator\">&amp;</span>zippo<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>     <span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span>                               \n<span class=\"token operator\">*</span>zippo<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>     <span class=\"token keyword\">int</span>                                      zippo<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\nzippo<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span>   <span class=\"token keyword\">int</span>\n<span class=\"token operator\">&amp;</span>zippo<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span>  <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>\n<span class=\"token operator\">*</span>zippo<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span>  invalid\n</code></pre></div>\n<p>끝끝내 이해가 안된다면 우선 외우고 차차 생각해보는 것도 방법이다!</p>\n<br/>\n<h3 id=\"-진짜-마지막으로-계산\" style=\"position:relative;\"><a href=\"#-%EC%A7%84%EC%A7%9C-%EB%A7%88%EC%A7%80%EB%A7%89%EC%9C%BC%EB%A1%9C-%EA%B3%84%EC%82%B0\" aria-label=\" 진짜 마지막으로 계산 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>👍 진짜 마지막으로 계산</h3>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> newarr<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>newpa<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> newarr<span class=\"token punctuation\">;</span>\n\nnewpa<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>newpa<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>\n<p><code class=\"language-text\">newpa[1][1]</code> = <code class=\"language-text\">(newpa[1])[1]</code></p>\n</li>\n<li>\n<p><code class=\"language-text\">newpa</code>는 <code class=\"language-text\">int(*)[3]</code> 자료형이므로 <code class=\"language-text\">(newpa[1])[1]</code> = <code class=\"language-text\">(newpa + 1 * (int [3]))[1]</code></p>\n</li>\n<li>\n<p><code class=\"language-text\">newpa[1]</code> = <code class=\"language-text\">{1, 2, 3}</code>이므로 <code class=\"language-text\">&amp;{1, 2, 3}[0]</code> 즉 <code class=\"language-text\">newpa[1]</code>는 <code class=\"language-text\">int *</code> 자료형</p>\n</li>\n<li>\n<p><code class=\"language-text\">(newpa[1])[1]</code> = <code class=\"language-text\">(newpa + 1 * (int [3])) + (1 * int)</code></p>\n</li>\n<li>\n<p><code class=\"language-text\">(newpa + (1 * int [3]))</code> = <code class=\"language-text\">(newpa + 12)</code></p>\n</li>\n<li>\n<p><code class=\"language-text\">(newpa + 1 * (int [3]))[1]</code> = <code class=\"language-text\">(newpa + 12) + (1 * int)</code></p>\n</li>\n<li>\n<p><code class=\"language-text\">(newpa + 12) + (1 * int)</code> = <code class=\"language-text\">(newpa + 12) +  (1 * 4)</code> = <code class=\"language-text\">newpa + 16</code></p>\n</li>\n<li>\n<p>따라서 <code class=\"language-text\">newpa[1][1]</code> = <code class=\"language-text\">*(&amp;newarr[0] + 16)</code></p>\n</li>\n<li>\n<p><code class=\"language-text\">*(&amp;newarr[0] + 16)</code> = <code class=\"language-text\">5</code> = <code class=\"language-text\">newarr[1][1]</code></p>\n</li>\n<li>\n<p><code class=\"language-text\">(*newpa)[1][1]</code> = <code class=\"language-text\">((*newpa)[1])[1]</code></p>\n</li>\n<li>\n<p><code class=\"language-text\">(*newpa)</code>는 <code class=\"language-text\">newarr[0]</code>의 내용에 바로 접근 = <code class=\"language-text\">{1, 2, 3}</code></p>\n</li>\n<li>\n<p><code class=\"language-text\">(*newpa)[1]</code>은 {1, 2, 3}[1] = <code class=\"language-text\">2</code></p>\n</li>\n<li>\n<p>따라서 <code class=\"language-text\">(*newpa)[1][1]</code>은 존재하지 않는 원소.</p>\n</li>\n</ul>\n<p>정신나갈것같아~ 일단 포인터는 여기까지만;;</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EF%B8%8F-%EB%B0%B0%EC%97%B4-%ED%8F%AC%EC%9D%B8%ED%84%B0%EB%8A%94-%EC%99%9C-%ED%95%84%EC%9A%94%ED%95%9C%EA%B0%80\">🤷‍♀️ 배열 포인터는 왜 필요한가?</a></p>\n<ul>\n<li><a href=\"#1-2%EC%B0%A8%EC%9B%90-%EB%B0%B0%EC%97%B4\">1. 2차원 배열?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%EC%8B%AC%ED%99%94-%EC%9E%90%EB%A3%8C%ED%98%95%EA%B3%BC-%ED%8F%AC%EC%9D%B8%ED%84%B0\">💡 심화: 자료형과 포인터</a></p>\n</li>\n<li>\n<p><a href=\"#-%EC%A7%84%EC%A7%9C-%EB%A7%88%EB%AC%B4%EB%A6%AC\">🙌 진짜 마무리</a></p>\n<ul>\n<li><a href=\"#-%EC%A7%84%EC%A7%9C-%EB%A7%88%EC%A7%80%EB%A7%89%EC%9C%BC%EB%A1%9C-%EA%B3%84%EC%82%B0\">👍 진짜 마지막으로 계산</a></li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"🤷‍♀️ 배열 포인터는 왜 필요한가? 앞서 우리는 배열 이름, 즉 배열의 첫 번째 원소의 주소가 아니라 배열 자체의 주소를 담기 위한 포인터를 생각해보았다. 왜 굳이 이런 포인터가 필요할까? 애초에 베열의 이름이 포인터와 유사한 기능을 (사실 포인터가 맞지만, 그 값을 변경할 수 없는 상수라는 점에서 차이가 있다) 하는데 왜 따로 배열 포인터를 정의하여 사용하는 것일까. 이는 2차원 이상의 배열을 가리킬 때 포인터를 통해 배열과 같이 인덱싱()을 할 수 있도록 하기 위함이다. 한 마디로, 포인터를 배열처럼 사용하기 위해서 배열 포인터를 정의하여 사용한다. 1. 2차원 배열? 2차원 배열을 생각해 보자. 위 경우  짜리 배열 2 개가 메모리에 연속적으로 존재하는 것이다. 여기서 를 사용하여 2차원 배열의 열, 행의 개수를 계산할 수 있다: 코드 출처: https://modoocode.com/25 여기서, 당연하게도 은  자료형의 배열이고, 총 6개의 원소들은 전부  자료형이므로 각 행의 …","frontmatter":{"date":"April 06, 2022","title":"(C) 포인터 벼락치기 5. 포인터와 배열의 자료형","categories":"C 42Seoul","author":"규자","emoji":"🌱"},"fields":{"slug":"/c-pointer-cram-5/"}},"next":{"id":"82e36ea1-21ab-5a64-9cca-696a305ebfd2","html":"<h2 id=\"️-포인터-정리하기-️\" style=\"position:relative;\"><a href=\"#%EF%B8%8F-%ED%8F%AC%EC%9D%B8%ED%84%B0-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0-%EF%B8%8F\" aria-label=\"️ 포인터 정리하기 ️ permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>⭐️ 포인터 정리하기 ⭐️</h2>\n<p>이틀만에 꽤나 많은 내용을 머릿속에 집어넣었다. 인풋이 많으면 반드시 꼬이는 법이라, 잠깐 포인터의 핵심들을 직관적으로 짚어보고 넘어가려고 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>p <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>parr <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">;</span></code></pre></div>\n<p>자, 코드를 보면서 천천히 되짚어보자.</p>\n<ol>\n<li>포인터는 특정 변수의 메모리 상 <strong>주소값</strong> 을 담고 있다.</li>\n<li>포인터는 변수다. 가리키는 주소는 변경될 수 있다.</li>\n<li>포인터는 가리킬 변수의 자료형 및 참조 연산자 <code class=\"language-text\">*</code>를 결합하여 만든다: <code class=\"language-text\">int *p;</code></li>\n<li><em>변수명을 떼어내면 변수의 형태를 알 수 있다.</em> <code class=\"language-text\">p</code>는 <code class=\"language-text\">int *</code>형 변수라고 생각하자.</li>\n<li>배열은 원소들의 집합이다. 이 원소들은 메모리 상에 <strong>연속적으로</strong> 위치한다.</li>\n<li><strong>배열 이름은 첫 번째 원소의 주소를 가리키는 포인터로 타입 변환된다.</strong> 단, <code class=\"language-text\">sizeof</code>나 <code class=\"language-text\">&amp;</code> 연산자가 쓰인 경우는 예외다.</li>\n<li><strong>이 때 배열 이름은 포인터 ‘상수’로 변환된다.</strong> 즉, <code class=\"language-text\">++</code>이나 <code class=\"language-text\">--</code>, <code class=\"language-text\">+=</code> 등으로 원본을 변경할 수 없다.</li>\n<li><code class=\"language-text\">arr[i]</code>와 같이, 배열 이름 뒤에 <code class=\"language-text\">[]</code> 연산자가 사용될 경우 컴파일러는 이를 <code class=\"language-text\">*(arr + i)</code>로 변환한다.\n<ul>\n<li>이 때 <code class=\"language-text\">+</code> 연산자의 변환 규칙에 따라 i는 사실 <code class=\"language-text\">(배열에 담긴 원소 타입의 크기 * i)</code>이다.</li>\n</ul>\n</li>\n</ol>\n<br/>\n<h2 id=\"-이중-포인터-포인터의-포인터\" style=\"position:relative;\"><a href=\"#-%EC%9D%B4%EC%A4%91-%ED%8F%AC%EC%9D%B8%ED%84%B0-%ED%8F%AC%EC%9D%B8%ED%84%B0%EC%9D%98-%ED%8F%AC%EC%9D%B8%ED%84%B0\" aria-label=\" 이중 포인터 포인터의 포인터 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🪄 이중 포인터, 포인터의 포인터</h2>\n<blockquote>\n<p>여기서부터는 <code class=\"language-text\">*</code>이 두 개씩 붙은 변수가 튀어나온다. 헷갈릴 수 있으므로 위의 4번, <em>변수명을 떼어내면 변수의 형태를 알 수 있다</em> 는 점을 기억하자.</p>\n</blockquote>\n<p>자 그럼, 이번에는 <strong>포인터를 가리키는 포인터</strong>에 대해 생각해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>pa <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span>ppa <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>pa<span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"변수 a의 값은:  %d, 주소는 : %p\\n\"</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"변수 pa의 값은 : %p, 주소는 : %p\\n\"</span><span class=\"token punctuation\">,</span> pa<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>pa<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"변수 ppa의 값은 : %p, 주소는 : %p\\n\"</span><span class=\"token punctuation\">,</span> ppa<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>ppa<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"변수 a의 값은:  %d\\n\"</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"포인터 pa가 가리키는 주소의 실제 값은 : %d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>pa<span class=\"token punctuation\">)</span>\n<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"포인터 ppa가 가리키는 주소의 실제 값은: %p\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>ppa<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"이중 포인터 ppa가 가리키는 주소의 최종 값은: %p\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span>ppa<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이 코드를 잘 생각해 보길 바란다. 먼저, 위의 세 <code class=\"language-text\">printf</code>문에서 변수 a의 주소를 포인터 pa가 담고 있고, 그 포인터 pa의 주소를 포인터 ppa가 담고 있음을 확인할 수 있을 것이다.</p>\n<p>당연하게도, 포인터도 변수이므로 메모리 어딘가에 주소를 부여받고 공간이 있어야 한다!</p>\n<p>다만 헷갈리는 건 아래 네 줄의 <code class=\"language-text\">printf</code>문이다. 그 전에, 이중 포인터의 형태를 다시 한 번만 생각해 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span>ppa <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>pa<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span><span class=\"token operator\">*</span> <span class=\"token operator\">*</span>ppa <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>pa<span class=\"token punctuation\">;</span></code></pre></div>\n<p>위의 두 코드는 완전히 같은 코드다. 뭐 당연하다. 바보같을 수 있지만 나는 왜 <code class=\"language-text\">*</code> 연산자가 변수명 바로 앞에 나란히 붙어 있는지가 엄청나게 신경쓰여서 진도를 못 나갔다. 두 연산자가 나란히 붙어 있다고 다른 의미가 되는 게 아니라, <strong>변수명 바로 앞의 <code class=\"language-text\">*</code> 연산자</strong>는 해당 변수가 포인터임을 지정하는 역할을 하고, 그 앞의 나머지 <code class=\"language-text\">*</code>들은 몇 개가 되었든 해당 포인터가 가리킬 자료형을 뜻한다.</p>\n<p>즉, 포인터 <code class=\"language-text\">ppa</code>는 <code class=\"language-text\">int *</code> 자료형을 가리키는 포인터라는 뜻이다.</p>\n<p>이를 조금 더 잘 이해하기 위해서는 별 거 아니지만 <code class=\"language-text\">*</code>연산자가 <strong>오른쪽 우선</strong> 연산자라는 점을 기억하자. 이따 2차원 배열의 <code class=\"language-text\">[]</code> 연산자에서 헷갈릴 수 있어 미리 말하자면 <code class=\"language-text\">[]</code> 연산자는 <strong>왼쪽 우선</strong> 연산자다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"변수 a의 값은:  %d\\n\"</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"포인터 pa가 가리키는 주소의 실제 값은 : %d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>pa<span class=\"token punctuation\">)</span>\n<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"포인터 ppa가 가리키는 주소의 실제 값은: %p\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>ppa<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"이중 포인터 ppa가 가리키는 주소의 최종 값은: %p\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span>ppa<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>그렇다면 다시 이 네 줄의 코드로 돌아오자. 우선 <code class=\"language-text\">pa</code>가 <code class=\"language-text\">a</code>를 가리키고 있으므로, <code class=\"language-text\">a</code>와 <code class=\"language-text\">*pa</code>는 같은 값이다.</p>\n<p>한편, 앞서 말했듯 <code class=\"language-text\">ppa</code>는 <code class=\"language-text\">int *</code>자료형, 즉 포인터 <code class=\"language-text\">pa</code>를 가리키므로 <code class=\"language-text\">*ppa</code>는 <code class=\"language-text\">pa</code>의 값인 <strong><code class=\"language-text\">a</code>의 주소</strong>다. 그렇기 때문에 <code class=\"language-text\">**ppa</code>는 <code class=\"language-text\">*(a의 주소)</code>, 즉 <code class=\"language-text\">*pa</code>가 되어 위와 같이 a의 값을 나타내게 된다.</p>\n<br/>\n<h2 id=\"-배열의-포인터\" style=\"position:relative;\"><a href=\"#-%EB%B0%B0%EC%97%B4%EC%9D%98-%ED%8F%AC%EC%9D%B8%ED%84%B0\" aria-label=\" 배열의 포인터 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🏢 배열의 포인터</h2>\n<p>여길 생각해보기 전에 아래 코드의 다섯 변수의 자료형을 정확히 알고 있는지 생각해보자:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">char</span> a<span class=\"token punctuation\">;</span> <span class=\"token comment\">// char형, 1바이트</span>\n<span class=\"token keyword\">int</span> b<span class=\"token punctuation\">;</span> <span class=\"token comment\">// int형, 4바이트</span>\n<span class=\"token keyword\">double</span> c<span class=\"token punctuation\">;</span> <span class=\"token comment\">// double형, 8바이트</span>\n\n<span class=\"token keyword\">char</span> d<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// char [10]형, 10바이트</span>\n<span class=\"token keyword\">int</span> e<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// int [5][10]형, 200바이트</span></code></pre></div>\n<ul>\n<li>코드 출처: <a href=\"https://www.acmicpc.net/blog/view/32\">https://www.acmicpc.net/blog/view/32</a></li>\n</ul>\n<p>d, e를 보면, 뭔가 자료형이 이상하다. 그냥 char형, double형의 배열이 아닌 걸까?</p>\n<p><strong>아니다.</strong> 배열 또한 별개의 자료형이다. 그리고 배열의 크기가 다르면 다른 배열, 다른 자료형이다.</p>\n<p>예를 들어 char [10] 자료형과 char [11] 자료형은 엄연히 다른 자료형이다. 전자는 10바이트 크기의 자료형이고, 후자는 11바이트 크기의 자료형이다.</p>\n<p>물론 크기가 같아도 적힌 숫자가 다르면 다른 자료형이다. (ex, char [5][10], char [10][5])</p>\n<br/>\n<p>그럼 이제 배열의 포인터에 대한 이야기를 해보자.</p>\n<p>앞서 말했듯 배열도 별개의 자료형이기 때문에, 배열을 위한 포인터가 존재한다. 그 말인즉슨, <code class=\"language-text\">int a[10]</code> 이라는 변수를 보고 <strong>“int 자료형을 가리키는 포인터 <code class=\"language-text\">int *p</code>를 사용하면 되겠다!”</strong> 와는 다른 이야기를 지금부터 하겠다는 뜻이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span> <span class=\"token comment\">// int 변수를 위한 포인터</span>\n<span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>pa<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// int[10] 변수를 위한 포인터</span></code></pre></div>\n<p>여기서 a의 자료형은 <code class=\"language-text\">int</code>라고 생각하면 안된다! 이 때의 자료형은 <code class=\"language-text\">int[10]</code>이며, 크기는 <strong>40바이트</strong>다.</p>\n<p><strong>아니, 앞에서는 그렇게 안했잖아요? 🤔</strong></p>\n<br/>\n<h3 id=\"1-배열의-주소와-배열의-첫-번째-주소\" style=\"position:relative;\"><a href=\"#1-%EB%B0%B0%EC%97%B4%EC%9D%98-%EC%A3%BC%EC%86%8C%EC%99%80-%EB%B0%B0%EC%97%B4%EC%9D%98-%EC%B2%AB-%EB%B2%88%EC%A7%B8-%EC%A3%BC%EC%86%8C\" aria-label=\"1 배열의 주소와 배열의 첫 번째 주소 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 배열의 주소와, 배열의 ‘첫 번째’ 주소</h3>\n<p>그렇다. 우리는 지금까지 아래와 같이 <code class=\"language-text\">int</code> 형 배열을 <code class=\"language-text\">int</code> 포인터로 잘 가리켜 왔다:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>p <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span> <span class=\"token comment\">// int 자료형의 포인터 변수 p</span>\np<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// a[3] = 3;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">;</span> <span class=\"token comment\">// int [10] 자료형의 포인터 변수 p. p의 자료형은 int (*)[10]</span>\n<span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// a[3] = 3;</span></code></pre></div>\n<p>사실 포인터 <code class=\"language-text\">p</code>와 <code class=\"language-text\">pa</code> 둘 다 위의 코드를 보면 결과적으로 <code class=\"language-text\">a[3] = 3</code>과 같다는 점에서 거의 비슷하다고 볼 수 있다. 하지만 엄밀하게 말하면 <strong>포인터 <code class=\"language-text\">p</code>의 경우, 배열의 주소를 포인터 변수로 담은 것이 아니다. 오직 <code class=\"language-text\">a[0]</code>의 주소만 포인터로 담은 것이다.</strong></p>\n<p>우리는 앞에서 <code class=\"language-text\">[]</code> 연산자의 역할을 보았다. <code class=\"language-text\">arr[i]</code>는 컴파일러에 의해 <code class=\"language-text\">*(arr + i)</code>로 변환된다고 말이다. 마찬가지로, <code class=\"language-text\">a[0]</code>은 <code class=\"language-text\">*(a + 0)</code>으로 변환된다. 즉 포인터 자료형이다. 정리하자면\na라는 배열 자체는 <code class=\"language-text\">int [10]</code> 자료형이지만 a[0]은 <code class=\"language-text\">*(a + 0)</code>이고, 이는 <code class=\"language-text\">int *</code> 자료형이다.</p>\n<p>그럼 변수 <code class=\"language-text\">p</code>에는 오직 배열 <code class=\"language-text\">a</code>의 첫 번째 원소의 주소만 담긴 건데, 어떻게 <code class=\"language-text\">p[3]</code>과 같이 배열에 접근할 수 있는 걸까? 전혀 어렵게 생각할 것 없다. 바로 위에서 말했듯 <code class=\"language-text\">arr[i]</code>는 컴파일러에 의해 <code class=\"language-text\">*(arr + i)</code>로 변환된다. 따라서 <code class=\"language-text\">p[3]</code>은 <code class=\"language-text\">*(p + 3)</code>이고, 이를 풀어 적으면 <code class=\"language-text\">*(a[0] + 3)</code>이 된다. 다시 이것은 <code class=\"language-text\">*(*(a + 0) + 3)</code>이 된다.</p>\n<p>이 때 a라는 배열 자체는 <code class=\"language-text\">int [10]</code> 자료형이라고 해서 배열 이름 <code class=\"language-text\">a</code>가 <code class=\"language-text\">int [10]</code> 자료형이라고 헷갈려서는 안 된다. 우리는 앞에서 분명히 <strong>배열 이름은 배열의 첫 번째 원소의 주소를 가리키는 포인터 상수로 변환된다</strong>고 이야기했다. 그러니까 <code class=\"language-text\">int *p = a;</code>와 같이 <code class=\"language-text\">int *</code> 자료형의 포인터 p에 a를 대입할 수 있는 것이다. 이는 곧 <code class=\"language-text\">a[0]</code>의 주소를 대입한 것과 같으니까.</p>\n<br/>\n<h3 id=\"2-베열의-주소를-포인터에-넣자\" style=\"position:relative;\"><a href=\"#2-%EB%B2%A0%EC%97%B4%EC%9D%98-%EC%A3%BC%EC%86%8C%EB%A5%BC-%ED%8F%AC%EC%9D%B8%ED%84%B0%EC%97%90-%EB%84%A3%EC%9E%90\" aria-label=\"2 베열의 주소를 포인터에 넣자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 베열의 ‘주소’를 포인터에 넣자!</h3>\n<p>자, 돌고돌아 이 이야기의 핵심은 결국 <code class=\"language-text\">&amp;a</code>를 포인터에 넣고자 할 때는 자료형을 다르게 생각해야 한다는 것이다.  배열 이름 <code class=\"language-text\">a</code>가 아니라, 배열 자체의 주소인 <code class=\"language-text\">&amp;a</code>가 바로 우리가 이야기해볼 대상이다.</p>\n<p>앞서 우리는 포인터 변수는 <strong>접근할 주소</strong>와, <strong>접근할 크기</strong>를 알아야 한다고 이야기했다.접근할 주소는 포인터 변수의 값이 되고, 접근할 크기는 사용하고자 하는 자료형의 크기가 된다. 예를 들어 <code class=\"language-text\">int</code>형 포인터라면 접근할 크기는 <code class=\"language-text\">int</code>형의 크기인 4바이트가 될 것이다.</p>\n<p>그러면, 내가 ‘배열의 <u>첫 번째 원소</u>의 주소’가 아니라, <strong>배열 그 자체</strong>의 주소를 포인터에 넣고 싶으면 자료형의 크기를 얼마로 지정해야 할까?</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// int [10] 자료형 변수 a. 크기는 40 바이트</span>\n<span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">;</span> <span class=\"token comment\">// int [10] 자료형의 포인터 변수 p. p의 자료형은 int (*)[10]</span>\n<span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>pa <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> arrSize <span class=\"token operator\">=</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">int</span> ptrSize <span class=\"token operator\">=</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">int</span> wrngSize <span class=\"token operator\">=</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>pa<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\"</span><span class=\"token punctuation\">,</span> arrSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 40</span>\n<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\"</span><span class=\"token punctuation\">,</span> ptrSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 40</span>\n<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\"</span><span class=\"token punctuation\">,</span> wrngSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 8</span></code></pre></div>\n<ul>\n<li>코드 참고: <a href=\"https://www.acmicpc.net/blog/view/32\">https://www.acmicpc.net/blog/view/32</a></li>\n</ul>\n<p>위의 코드를 보자. <code class=\"language-text\">a</code>가 아닌 <code class=\"language-text\">&amp;a</code>를 담기 위해, <code class=\"language-text\">*p</code>가 아닌 <code class=\"language-text\">(*p)</code>가 쓰였다.</p>\n<p>앞서 말했듯 <strong>포인터 변수가 접근할 크기는 사용하고자 하는 자료형의 크기</strong>다. 배열 <code class=\"language-text\">a</code>자체는 40바이트(4 byte * 10)의 정보를 담을 수 있는 <code class=\"language-text\">int [10]</code> 형의 변수이므로, 배열 <code class=\"language-text\">a</code>의 주소를 담은 포인터 <code class=\"language-text\">p</code>가 접근할 크기 역시 40바이트여야 한다. 위의 코드에서 <code class=\"language-text\">sizeof</code>를 통해 확인해보니, 배열의 크기를 정확히 담고 있는 포인터는 <code class=\"language-text\">(*p)</code>, 즉 괄호로 감싸준 포인터임을 알 수 있다. 이처럼 <code class=\"language-text\">(*{변수명})</code> 형태로 사용되는 포인터는 <strong>배열 포인터</strong>라고 한다.</p>\n<p>그럼 다음 글에서 이 배열 포인터가 왜 필요한지 조금 더 자세히 이야기해보도록 하자.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EF%B8%8F-%ED%8F%AC%EC%9D%B8%ED%84%B0-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0-%EF%B8%8F\">⭐️ 포인터 정리하기 ⭐️</a></p>\n</li>\n<li>\n<p><a href=\"#-%EC%9D%B4%EC%A4%91-%ED%8F%AC%EC%9D%B8%ED%84%B0-%ED%8F%AC%EC%9D%B8%ED%84%B0%EC%9D%98-%ED%8F%AC%EC%9D%B8%ED%84%B0\">🪄 이중 포인터, 포인터의 포인터</a></p>\n</li>\n<li>\n<p><a href=\"#-%EB%B0%B0%EC%97%B4%EC%9D%98-%ED%8F%AC%EC%9D%B8%ED%84%B0\">🏢 배열의 포인터</a></p>\n<ul>\n<li><a href=\"#1-%EB%B0%B0%EC%97%B4%EC%9D%98-%EC%A3%BC%EC%86%8C%EC%99%80-%EB%B0%B0%EC%97%B4%EC%9D%98-%EC%B2%AB-%EB%B2%88%EC%A7%B8-%EC%A3%BC%EC%86%8C\">1. 배열의 주소와, 배열의 ‘첫 번째’ 주소</a></li>\n<li><a href=\"#2-%EB%B2%A0%EC%97%B4%EC%9D%98-%EC%A3%BC%EC%86%8C%EB%A5%BC-%ED%8F%AC%EC%9D%B8%ED%84%B0%EC%97%90-%EB%84%A3%EC%9E%90\">2. 베열의 ‘주소’를 포인터에 넣자!</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"April 05, 2022","title":"(C) 포인터 벼락치기 4. 이중 포인터와 배열 포인터","categories":"C 42Seoul","author":"규자","emoji":"🌱"},"fields":{"slug":"/c-pointer-cram-4/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://www.zoomkoding.com","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/c-pointer-cram-5/","nextSlug":"/c-pointer-cram-4/","prevSlug":""}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}
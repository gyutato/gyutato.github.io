{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/42Seoul",
    "result": {"pageContext":{"currentCategory":"42Seoul","categories":["All","C","42Seoul","frontend","TypeScript","JavaScript"],"edges":[{"node":{"id":"d026fe1d-c523-541c-9950-1c536f008a8d","excerpt":"🤷‍♀️ 배열 포인터는 왜 필요한가? 앞서 우리는 배열 이름, 즉 배열의 첫 번째 원소의 주소가 아니라 배열 자체의 주소를 담기 위한 포인터를 생각해보았다. 왜 굳이 이런 포인터가 필요할까? 애초에 베열의 이름이 포인터와 유사한 기능을 (사실 포인터가 맞지만, 그 값을 변경할 수 없는 상수라는 점에서 차이가 있다) 하는데 왜 따로 배열 포인터를 정의하여 사용하는 것일까. 이는 2차원 이상의 배열을 가리킬 때 포인터를 통해 배열과 같이 인덱싱()을 할 수 있도록 하기 위함이다. 한 마디로, 포인터를 배열처럼 사용하기 위해서 배열 포인터를 정의하여 사용한다. 1. 2차원 배열? 2차원 배열을 생각해 보자. 위 경우  짜리 배열 2 개가 메모리에 연속적으로 존재하는 것이다. 여기서 를 사용하여 2차원 배열의 열, 행의 개수를 계산할 수 있다: 코드 출처: https://modoocode.com/25 여기서, 당연하게도 은  자료형의 배열이고, 총 6개의 원소들은 전부  자료형이므로 각 행의 …","fields":{"slug":"/c-pointer-cram-5/"},"frontmatter":{"categories":"C 42Seoul","title":"(C) 포인터 벼락치기 5. 포인터와 배열의 자료형","date":"April 06, 2022"}},"next":{"fields":{"slug":"/c-pointer-cram-4/"}},"previous":null},{"node":{"id":"82e36ea1-21ab-5a64-9cca-696a305ebfd2","excerpt":"⭐️ 포인터 정리하기 ⭐️ 이틀만에 꽤나 많은 내용을 머릿속에 집어넣었다. 인풋이 많으면 반드시 꼬이는 법이라, 잠깐 포인터의 핵심들을 직관적으로 짚어보고 넘어가려고 한다. 자, 코드를 보면서 천천히 되짚어보자. 포인터는 특정 변수의 메모리 상 주소값 을 담고 있다. 포인터는 변수다. 가리키는 주소는 변경될 수 있다. 포인터는 가리킬 변수의 자료형 및 참조 연산자 를 결합하여 만든다:  변수명을 떼어내면 변수의 형태를 알 수 있다. 는 형 변수라고 생각하자. 배열은 원소들의 집합이다. 이 원소들은 메모리 상에 연속적으로 위치한다. 배열 이름은 첫 번째 원소의 주소를 가리키는 포인터로 타입 변환된다. 단, 나  연산자가 쓰인 경우는 예외다. 이 때 배열 이름은 포인터 ‘상수’로 변환된다. 즉, 이나 ,  등으로 원본을 변경할 수 없다. 와 같이, 배열 이름 뒤에  연산자가 사용될 경우 컴파일러는 이를 로 변환한다. 이 때  연산자의 변환 규칙에 따라 i는 사실 이다. 🪄 이중 포인터, …","fields":{"slug":"/c-pointer-cram-4/"},"frontmatter":{"categories":"C 42Seoul","title":"(C) 포인터 벼락치기 4. 이중 포인터와 배열 포인터","date":"April 05, 2022"}},"next":{"fields":{"slug":"/c-pointer-cram-3/"}},"previous":{"fields":{"slug":"/c-pointer-cram-5/"}}},{"node":{"id":"834712e6-3610-5a06-a14a-29dde5cb2c06","excerpt":"⭐️ 배열과 포인터 ⭐️ 개인적으로 여태 C언어를 공부하면서 가장 어려웠던 부분이지만, 타 언어에 비해 C언어 공부가 더욱 흥미로운 이유이기도 했던 배열과 포인터의 관계를 이야기해보자. 먼저, 배열에 대한 기억을 되짚어 보자. 배열이란 간단히 다음과 같았다: 변수가 여러개 모인 것 메모리 상에 연속되게 놓여 있는 원소(변수)들의 집합에 이름붙인 것 여기서 2차원, 3차원 등 고차원 배열도 만들 수 있었지만 결국 이것들도 메모리 상에서는 1차원 평면 위에 연속되게 놓여 있는 형태가 된다. 코드 출처: 모두의 코드 씹어먹는 C 언어(https://modoocode.com/24) 위 코드를 컴파일해보면, arr[0]부터 arr[9]까지 각 원소들의 주소값이 4씩 증가하며 연속적으로 위치하고 있음을 확인할 수 있다. 연속적이라고? 바로 앞에서 우리는 포인터에 + 1을 해주면 (ex. ) 그 다음 값에 접근할 수 있음을 확인했다. 그 말인 즉슨, 배열의 첫 번째 원소의 주소값을 포인터에 넣어 …","fields":{"slug":"/c-pointer-cram-3/"},"frontmatter":{"categories":"C 42Seoul","title":"(C) 포인터 벼락치기 3. 포인터와 배열","date":"April 05, 2022"}},"next":{"fields":{"slug":"/c-pointer-cram-2/"}},"previous":{"fields":{"slug":"/c-pointer-cram-4/"}}},{"node":{"id":"5eb13f75-7308-5000-a9e9-709c0754d441","excerpt":"🧬 포인터의 타입 앞에서 우리는 포인터가 메모리 상에서 특정 데이터가 위치해있는 주소를 담고 있다는 사실을 알아보았다. 이 메모리의 주소는 각 ‘방’들을 구분하기 위해 각각의 ‘방’에 부여되어 있다고 했다. 그런데 이 ‘방’ 들은 일반적으로 각 1바이트이고, 각 자료형은 를 제외하고 대부분 2바이트 이상이다. 대표적으로 int 자료형은 4바이트 아닌가. 그렇다는 건 4개의 ‘방’을 차지하고 있다는 건데, 그 중 포인터는 어느 방을 가리키고 있는 것이며, 어디까지 한 개의 데이터로 인식할 수 있는 것일까? 여기서 포인터의 ‘타입’과 관련된 문제가 발생한다. 각 자료형이 차지할 수 있는 바이트의 크기를 명시하여 포인터에도 동일한 타입을 부여해주지 않으면, 메모리에서 얼마만큼을 읽어들여야 할 지 알 수 없게 된다. 왜냐하면 포인터에게 전달되는 주소값은 해당 변수(데이터)가 메모리에서 차지하는 모든 주소들의 위치가 들어있는 것이 아니라 시작 주소만 들어가 있기 때문이다! 1. 포인터와 변…","fields":{"slug":"/c-pointer-cram-2/"},"frontmatter":{"categories":"C 42Seoul","title":"(C) 포인터 벼락치기 2. 포인터의 타입과 상수 포인터","date":"April 04, 2022"}},"next":{"fields":{"slug":"/c-pointer-cram-1/"}},"previous":{"fields":{"slug":"/c-pointer-cram-3/"}}},{"node":{"id":"a2fcb012-9e17-5b8e-a2d1-bc3121be7652","excerpt":"🔄 타입 캐스팅 (형 변환) 가끔씩 프로그래밍을 하다 보면 형이 다른 변수 끼리 대입을 하는 연산을 필요로 한다. 예를 들어서  형 변수의 값을  형 변수에 대입하거나,  형 변수에  형 변수의 값을 대입하는 경우다. 하지만 형이 다른 변수 끼리의 대입이나 연산은 컴파일이 불가능하거나, warning을 띄우게 된다.  형 변수에  형 변수를 대입하면 소수 부분이 잘려서 정수 부분만 들어간다. 컴파일러는 이에 따른 데이터 손실에 대한 warning을 띄운다 (error가 아니기에 컴파일은 된다). 여기서는 컴파일러가 암묵적으로 형 변환을 해주었지만, 다른 사람에게 이 코드를 보여준다고 생각하면 명시적으로 형 변환을 밝혀 주는 것이 좋겠다. 의 자료형은 로 선언되어 있으므로 의 앞에 를 붙여 형 변환 시킨 값을 에 넣어주겠다는 뜻이다. 형 변환 자체가 어려운 개념은 아니지만, 어쨌든 내가 선언한 변수가 컴파일 과정에서 다른 타입으로 변환되어 계산될 수 있다는 사실을 인지하는 것은 중요…","fields":{"slug":"/c-pointer-cram-1/"},"frontmatter":{"categories":"C 42Seoul","title":"(C) 포인터 벼락치기 1. 형 변환과 포인터","date":"April 04, 2022"}},"next":{"fields":{"slug":"/SCSS-grammar/"}},"previous":{"fields":{"slug":"/c-pointer-cram-2/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}
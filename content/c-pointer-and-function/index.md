---
emoji: 🌱
title: (C) 포인터를 써먹자! 포인터와 함수
date: '2022-04-08 23:06:12'
author: 규자
tags: C pointer function
categories: C 42Seoul
---

## 🪄 블록과 변수의 범위
코드를 작성하다 보면 우리는 다양한 변수를, 다양한 위치에서 사용하게 된다:
```cpp
#include <stdio.h>

int addOne(int a, int b) {
    a += 1;
    b += 1;
}
int main() {
    int a = 0, b = 10;
    printf("a = %d, b = %d\n", a, b);
    addOne(a, b)
    printf("a + 1 = %d, b + 1 = %d\n", a, b);
    return 0;
}
```
<br/>

우리는 분명 `addOne` 함수를 사용하여 `a`와 `b`의 값에 각각 1씩 더해주고 싶었는데, 함수를 실행했음에도 불구하고 `a`와 `b`의 값에는 변화가 없다. 이는 **블록**과 **변수의 범위(scope)** 와 관련이 있다.

<br/>

### 1. `main()`도 함수다 (당연하다)

C 언어에서 중괄호로 묶은 부분을 블록이라고 부른다. 변수는 선언된 블록 안에서만 사용(접근)할 수 있고 블록 바깥에서는 사용(접근)할 수 없다. 이를 변수의 범위(scope)라고 한다. C 언어를 컴파일할 때 컴퓨터는 가장 먼저 `main()`함수를 찾아 실행시킨다. 이는 수많은 함수들 중 무엇을 가장 먼저 실행시켜야 하는지 컴퓨터에게 알려주기 위한 규칙이다. 즉, `main()`도 어찌되었든 **함수**라는 것이다. 가장 먼저 실행된다는 사실을 제외하면 `addOne()`과 `main()`은 다를 것이 없다.

코드를 보면 `addOne()`과 `main()`의 내용들은 각각 `{}`로 묶여 있다. 이것이 블록이다. 각기 다른 블록 내에서 선언된 변수들은 완전히 별개의 메모리 공간을 가진다. 

다른 블록에서 선언된 어떤 변수를 인자로 받아 함수의 매개변수로 사용할 때에도 마찬가지다. 포인터를 사용하지 않고 위의 코드와 같이 (포인터가 아닌) 변수를 그대로 넘겨줄 경우, 이는 **값에 의한 전달(call by value)이다**. 

<br/>

### 2. 값에 의한 전달 (call by value)
**값에 의한 전달** 방법은 인수로 전달되는 변수가 가지고 있는 값을 함수 내의 매개변수에 복사하는 방식이다. 여기서 **복사**라는 말이 중요하다. 인수로 전달되는 변수를 직접 참조하는 것이 아니라, 그 변수의 값만 가지고 와서 함수 내부의 **매개변수의 값을 초기화**하는 것이다. 

그러므로 이렇게 복사된 값으로 초기화된 매개변수는 인수로 전달된 변수와는 완전히 별개의 변수가 된다. 따라서 함수 내에서의 매개변수 조작은 인수로 전달되는 변수에 아무런 영향을 미치지 않는다.

```cpp
void addOne(int num1, int num2) {num1 += 1; num2 +=1;}
int main() {
    int a = 0, b = 10;
    addOne(a, b);
    printf("a + 1 = %d, b + 1 = %d\n", a, b);
    return 0;
}
```
즉 위의 코드에서 매개변수 `num1`에 변수 `a`를, 또다른 매개변수 `num2`에 변수 `b`를 넘겨줬지만, **이때 `num1 == a`는 맞고 `&num1 == &a`는 틀리다**. 값만 같아질 뿐 여전히 별개의 변수이므로, `addOne` 함수 내부에서 `num1`과 `num2`를 아무리 조작해 봤자 `main`함수의 `a`, `b` 값에는 아무런 영향을 끼칠 수 없다.

<br/>

## 📌 포인터를 인자로 받는 함수
그치만... 다른 함수의 값을 또다른 함수가 조작하지 못한다면 "매개변수"라는 닉값을 너무 못하는 것 같다는 생각이 든다. 단지 값을 복사해오는 정도로는 함수 간을 충분히 매개해준다고 말하기 어렵지 않나?


### 1. 포인터로 '주소'에 접근하기: call by reference
사실 함수에 인수를 전달하는 방법에는 값에 의한 전달(call by value)외에 한 가지가 더 있다. **참조에 의한 전달(call by reference)** 이다. 

참조에 의한 전달 방법이란 위처럼 인수로 어떤 변수의 '값'을 전달하는 것이 아니라, 어떤 변수의 **'주소값'** 을 전달하는 방식이다. 즉, 함수의 매개변수에 인수로 전달된 변수의 원래 주소값을 저장하는 것이다. 이 방식을 사용하면 해당 변수의 값을 복사해오는 것이 아니라 그 변수가 저장되어 있는 메모리상의 '공간'에 접근할 수 있으므로, 그 값을 직접 조작할 수 있게 된다.

```cpp
void addOne(int *num1, int *num2) {*num1 += 1; *num2 +=1;}
int main() {
    int a = 0, b = 10;
    addOne(&a, &b);
    printf("a + 1 = %d, b + 1 = %d\n", a, b);
    return 0;
}
```
그럼 이 코드는 어떨까? 인자로 `int *` 자료형을 사용하고 있다. 따라서 매개변수 `num1`, `num2`는 주어질 변수의 값을 복사해오는 것이 아니라 그 '주소'를 넘겨받는다. 그러면 역참조 연산자를 사용하여 `*num1`, `*num2`를 통해 해당 주소에 있는 값, 즉 `a`와 `b`의 값을 조작할 수 있다.

<br/>

### 2. 이중 포인터를 인자로 사용하기
방금까지 `int` 자료형의 값을 실제로 조작하기 위해 `int *`자료형 매개변수를 사용해보았다. 그러면 한 단계 나아가서, `int *`을 포함한 '포인터' 자료형을 조작하기 위해 `int **` 등 '이중 포인터' 인자를 사용할 수도 있을까?

당연하다!

```cpp
#include <stdio.h>
int switchAddr(int **ppa, int **ppb) {
    int *temp;

    temp = *ppa;
    *ppa = *ppb;
    *ppb = temp;

    return 1;
}
int main() {
    int a, b;
    int *pa, *pb;
    pa = &a;
    pb = &b;

    printf("pa가 가리키는 곳 : %p\n", pa);
    printf("pb가 가리키는 곳 : %p\n", pb);

    if (switchAddr(&pa, &pb) == 1) {
      printf("\n=====switchAddr 함수 실행=====\n");
    }

    printf("\npa가 가리키는 곳 : %p\n", pa);
    printf("pb가 가리키는 곳 : %p\n", pb);
}
```
우선, `switchAddr`의 `int **ppa` `int **ppb`는 `int **` 자료형의 매개변수다. 

그 다음 `main` 함수에서 `int` 자료형 변수 `a`,`b`를 선언했다. 그리고 `int *`형 포인터 변수 `pa`, `pb`를 선언하여 각각에 `a`, `b`의 주소를 담았다.

그러면 여기서 `pa == {a의 주소}`이고, `*pa == {a의 값}`이다. 즉 `pa`의 값은 **가리키고 있는 변수의 주소**이고, `pa가 가리키는 주소의 값`은 **가리키고 있는 변수의 값**이다. (단어가 길어지지만 어쩔 수 없었다ㅠㅠ)

이 `pa`의 값, 즉 어느 변수의 주소를 가리킬지를 조작하기 위해서는 `pa`를 가리킬 수 있는 포인터, 즉 `int **`형 매개변수를 사용해야겠다. 그것이 바로 `switchAddr`의 `int **ppa` 이다. 

이 다음 우리는 `switchAddr(&pa, &pb)`를 통해 `int **ppa`에게  포인터 `pa`의 **주소**를 넘겨주었다. 따라서 `ppa == {pa의 주소}`이고, `*ppa == {pa의 값}`이다! 

즉 `*ppa`는 `pa`의 값, 즉 변수 a를 가리키는 메모리 주소다. 그러면 마찬가지의 과정을 거쳤으니 `*ppb`는 `pb`의 값, 즉 변수 a를 가리키는 메모리 주소다.

```cpp
int *temp;

temp = *ppa;
*ppa = *ppb;
*ppb = temp;
```
`switchAddr` 함수의 이 부분을 통해, `*ppa` 즉 `pa`의 값은 `a`의 주소가 아닌 `b`의 주소로 변경되었다.

```cpp
printf("\npa가 가리키는 곳 : %p\n", pa);
```
따라서 이 코드의 결과로 앞서 `b`의 주소였던 메모리 주소가 출력되게 된다.

이런 코드가 도대체 왜 필요한가? 우리는 다른 함수의 변수값을 조작하기 위해 포인터를 사용할 것이고, 어떤 포인터가 어떤 변수를 가리켜야 하는지, 즉 어떤 포인터가 어떤 변수를 조작해야 하는지는 프로그래밍 상황에 따라 수시로 변경될 수 있기 때문이다. (라고 생각한다)

<br/>

## 📌 배열을 인자로 받는 함수
사실 우리는 어떤 정보를 단독으로 쓰는 경우보다, 관련된 정보를 하나의 집합으로 묶어서 사용하는 경우를 많이 겪을 것이다 (구조체, 배열 등). 당연히 다른 함수에서 선언된 배열을 인자로 받아 그 원소들에 접근 및 조작해야 하는 상황이 생긴다.

```cpp
#include <stdio.h>

void arrAdd(int (*parr)[3], int row) {
    int i, j;

    for (i = 0; i < row; i++) {
        for (j = 0; j < 3; j++) {
            parr[i][j]++;
        }
    }
}

int main() {
    int arr[2][3];
    int i, j;

    for (i = 0; i < 2; i++) {
        for (j = 0; j < 3; j++) {
            printf("arr 배열의 [%d][%d]번째 원소를 입력: ", i, j);
            scanf("%d", &arr[i][j]);
        }
    }

    arrAdd(arr);

    printf("arr 배열의 값: ")
    for (i = 0; i < 2; i++) {
        for (j = 0; j < 3; j++) {
            printf("%d", arr[i][j]);
        }
    }

    return 0;
}
```

이처럼 포인터를 사용하여 배열의 값에 접근할 수 있다 (당연하다). 다만 2차원 이상의 배열을 포인터로 가리킬 때에는 그 포인터의 자료형이 배열의 자료형과 제대로 일치하고 있는지 신경써야 한다. 즉 이전 포인터 벼락치기를 통해 길게 설명했듯 포인터가 배열의 첫 번째 원소의 자료형을 잘 가리키고 있는지 유의해야 한다!
---
emoji: 🌱
title: (C) 표준 스트림과 stdin, scanf
date: '2022-04-09 14:08:13'
author: 규자
tags: C 
categories: C 42Seoul
---

## 🤯 `scanf`의 문제
```cpp
/* 이상한 scanf */
#include <stdio.h>
int main() {
  int num;
  char c;

  printf("숫자를 입력하세요 : ");
  scanf("%d", &num);

  printf("문자를 입력하세요 : ");
  scanf("%c", &c);
  return 0;
}
```

종종 여러 번의 입력을 받는 경우 개행문자나 공백문자 등이 버퍼 내부에 남아 있다가 다음 `scanf`의 입력으로 들어가서 사용자 입력이 불가능해지는 경우가 생긴다. 키보드로 입력되는 모든 정보는 일시적으로 `stdin` 버퍼에 저장되어 있다가 `scanf` 등의 함수로 한꺼번에 처리된다.

<br/>

### 💽 `stdin` 버퍼

#### 📌 잠시 유닉스 이야기
> **위키백과 [스트림 (컴퓨팅)] 항목:**<br/>C 프로그래밍 언어에 기반을 둔 유닉스 관련 시스템에서 스트림은 개별 바이트나 문자열인 데이터의 원천이다. 스트림들은 파일을 읽거나 쓸 때, 네트워크 소켓을 거쳐 통신할 때 쓰이는 추상적인 개념이다. 표준 스트림들은 모든 프로그램에 이용할 수 있는 세 개의 스트림을 말한다.


일반적으로 유닉스에서 동작하는 프로그램은 실행 시 세 개의 스트림이 자동으로 열린다. 이를 표준 스트림이라고 부른다. 하나는 입력을 위한 스트림(Standard input, `STDIN`, 0), 하나는 출력을 위한 스트림(Standard Output, `STDOUT`, 1), 하나는 오류 메시지를 출력하기 위한 스트림(Standard Error, `STDERR`, 2)이며, 이 세 개의 표준 스트림은 <u>사용자의 터미널에 부착된다</u>.

보통 터미널에 로그인 셸이 먼저 기동되고, (사용자 인증이 끝나면) 대화형 셸이 기동된다. 이때 자동으로 터미널에 부착된 세 개의 표준 스트림이 상속된다. 이후, 셸에서 실행되는(exec) 모든 명령들은, 셸을 부모 프로세스로 삼아 세 개의 표준 스트림을 다시 상속 받는다. 더 일반적으로 말하자면, 자식 프로세스는 부모 프로세스의 표준 스트림을 상속 받는다고 할 수 있다.

표준 C 실행 라이브러리의 `<stdio.h>` 헤더에서 stdin, stdout, stderr 로 정의되며, `<unistd.h>`에 의해 **파일 디스크립터** `0`, `1`, `2` 로 표현하기도 한다.

유닉스 이전에는 내 프로그램이 어떤 종류의 입출력 장치와 연결되는지 코드상에 명시적으로 알려주어야 했으며, 그 장치가 데이터를 얼마나(어떤 크기만큼), 어떤 형태로 사용해야 하는지 프로그램이 알아야 했다. 그러나 유닉스는 **데이터 스트림**이라는 개념으로 순차적인 데이터 바이트들을 파일의 끝(EOF)까지 읽어들이는 방식을 통해 이러한 불편함을 해소했다. 이런 방식으로, 프로그램은 쓸 데이터가 얼만큼 남았는지, 혹은 어떤 식으로 묶여있는지 알 필요 없이 필요한 데이터를 쓸 수 있었다. 또 하나의 발전은 **자동으로 연결되는 입출력 장치**였다. 프로그램이나 프로그래머가 입출력을 사용할 때 어떤 장치를 어떻게 연결하는지 명시적으로 작업해줄 필요 없이, 추상화된 입출력 장치, 즉 이 **표준 스트림**을 사용하면 된다.

<br/>

#### 📌 그래서 `stdin`이란
`stdin`, 즉 표준 입력은 **프로그램으로 들어가는 <u>데이터(보통은 문자열) 스트림</u>** 이다. 프로그램은 read 명령을 이용하여 데이터 전송을 요청한다. 모든 프로그램이 입력을 요구하는 것은 아니다. 이를테면 dir이나 ls 프로그램(디렉터리에 들어 있는 파일 이름을 보여 주는 명령)은 실행시 옵션과 같은 명령줄 매개변수를 받을 수는 있으나, 동작 중에 데이터 스트림의 입력 없이 명령을 수행한다.

별도의 리다이렉션 없이 프로그램을 시작한 경우, 표준 입력 스트림은 키보드에서 받아온다.

표준 입력을 위한 파일 서술자는 0이다. POSIX <unistd.h> 정의는 STDIN_FILENO이다. 이에 해당하는 <stdio.h> 변수는 FILE* stdin;이다. 이와 비슷하게 <iostream>에서는 std::cin이다.


## 🛠 문자열 제어 함수 구현해보기
### 1. 문자열 복사 함수
```cpp
/* int copy_str(char *dest, char *src);
src 의 문자열을 dest 로 복사한다. 단, dest 의 크기가 반드시 src 보다 커야 한다 */

#include <stdio.h>
int copy_str(char *dest, char *src);
int main() {
  char str1[] = "hello";
  char str2[] = "hi";

  printf("복사 이전 : %s \n", str1);
  copy_str(str1, str2);
  printf("복사 이후 : %s \n ", str1);

  return 0;
}

int copy_str(char *dest, char *src) {
  while (*src) {
    *dest = *src; 
    // 포인터 역참조로 값에 접근하자!

    src++; // 포인터가 가리키는 주소를 증가시키고 반복문으로 재접근하면 다음 원소를 읽어들일 수 있다.
    dest++;
  }
  *dest = 0; 
  // printf에서 %s 형태로 읽어올 것이므로 마지막에 문자열의 끝을 알리는 0 또는 '\0'이 필요하다.
  // 안그러면 뒤의 'llo'까지 읽혀 'hillo'가 될 것이다.

  return 1;
}
```

**생각해볼 점:**
- 배열에 꼭 인덱스로 접근해야 한다는 생각을 **아예** 버리자.
    - 포인터 형태로 접근하는 방법을 항상 생각하자. 증감 연산으로 얼마든지 어떤 요소든 가리킬 수 있다.
- 문자열을 읽어올 때 뒤에 내용이 남았더라도 숫자(문자 아님) `0`이나 `'\0'`을 만나면 끝난다.
- 문자열을 다룰 때 `while (*{배열이름 또는 포인터})` 방법을 기억하자.

<br/>

### 2. 문자열을 합치는 함수
```cpp
#include <stdio.h>
int stradd(char *str1, char *str2) {
    int i = 0;
    while (*str1){
        str1++; // str1이 가리키는 주소값을 반복적으로 증가시켜 문자열의 끝을 가리키게 한다
    }
    while (*str2){
        *str1 = *str2;
        
        str2++;
        str1++;
    }
    *str1 = 0;
    return 1;
}

int main() {
    char str1[100] = "hello my name is ";
    char str2[] = "Olivia";
    // str1 은 "hello my name is Olivia" 가 된다.
    
    stradd(str1, str2);
    
    printf("%s", str1);
    
    return 0;
}
```
**생각해볼 점:**
- 배열을 가리키는 포인터 자체를 증가시켜 바로바로 다음 원소의 메모리 공간에 접근할 수 있다.
    - `int i = 0; while(*str1){int++; str1++;} str1 += i` 이런 식으로 두 번 일하지 말자 `i`는 필요없다.
    - 즉, `{포인터}`와 `*{포인터}`를 적절히 섞어서 잘 사용하자.
- `str1`은 배열 이름이니까 상수인데, 직접 증감 연산이 가능한가?
    - 라는 바보같은 생각을 하지 말자 (이미 했다). 그 주소값을 stradd 함수의 두 인자에 복사해서 넘겨준 셈이다.
    - stradd 함수의 두 인자는 `const char *`가 아니라 `char *`이므로 증감 연산이 가능하다.

<br/>

### 3. 문자열을 비교하는 함수
내가 생각한 함수는 이렇다:
```cpp
#include <stdio.h>

int compare(char *str1, char *str2) {
    int i = 0;
    
    while (*str1) {i++; str1++;}
    while (*str2) {i--; str2++;}
    
    if (i == 0) {
        while (*str1) {
            if (*str1 == *str2) {str1++; str2++;} 
            else {return 0;}
        } 
        return 1;
    } else {return 0;}
}
```
좀 더 간단한 함수는 아래와 같다:
```cpp
int compare(char *str1, char *str2) {
  while (*str1) {
    if (*str1 != *str2) {
      return 0;
    }

    str1++;
    str2++;
  }

  if (*str2 == '\0') return 1;

  return 0;
}
```
- 코드 출처: 모두의 코드 씹어먹는 C 언어 (https://modoocode.com/33)
**생각해볼 점**
- **절대** 무턱대로 함수부터 끄적거리지 말자. 반드시 아래의 3개를 종이든 머릿속이든 분명히 구체화시켜놓고 코드로 옮기자:
    - 이 함수는 무슨 작업을 하는가? **(자세할수록 좋다)**
    - 함수의 리턴형이 무엇이면 좋을까?
    - 함수의 인자으로는 무엇을 받아야 하는가?
- 최대한 간단하게 생각하자. 생각의 나래를 무작정 펴지 말고 길을 닦아 나가자.
- 예외인 경우나 에러 처리를 함수의 윗 부분에 해주는 게 깔끔한 경우도 있다 (뒤를 더 볼 필요 없이 에러를 뱉으면 되는 경우)
- 생각이 막혀서 최악의 경우 하드코딩을 하게 되더라도 우선 결과를 구현해내서 끝을 보자.
    - 조금 고민하다가 답부터 참고하는 것과 어떻게든 결과를 내어 놓고 답과 비교하는 것은 정말 천지차이다!

```toc
```
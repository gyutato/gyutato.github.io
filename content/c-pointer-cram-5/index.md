---
emoji: 🌱
title: C 포인터 벼락치기 (5) 포인터와 배열의 자료형
date: '2022-04-06 11:06:12'
author: 규자
tags: Basics C
categories: Basics C 42Seoul
---

## 배열 포인터는 왜 필요한가?
앞서 우리는 배열 이름, 즉 배열의 첫 번째 원소의 주소가 아니라 **배열 자체의 주소**를 담기 위한 포인터를 생각해보았다. 왜 굳이 이런 포인터가 필요할까? 애초에 베열의 이름이 포인터와 유사한 기능을 (사실 포인터가 맞지만, 그 값을 변경할 수 없는 상수라는 점에서 차이가 있다) 하는데 왜 따로 배열 포인터를 정의하여 사용하는 것일까. 이는 **2차원 이상의 배열**을 가리킬 때 포인터를 통해 배열과 같이 인덱싱(`[]`)을 할 수 있도록 하기 위함이다.

한 마디로, 포인터를 배열처럼 사용하기 위해서 배열 포인터를 정의하여 사용한다.

<br/>

### 2차원 배열?
```cpp
int a[2][3];
```
2차원 배열을 생각해 보자. 위 경우 `int a[3]` 짜리 배열 2 개가 메모리에 연속적으로 존재하는 것이다. 여기서 `sizeof`를 사용하여 2차원 배열의 열, 행의 개수를 계산할 수 있다:
```cpp
int main() {
  int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};
  
  printf("전체 크기 : %d \n", sizeof(arr));
  // 배열의 전체 크기 = 2 * 3 * 4 = 12

  printf("총 열의 개수 : %d \n", sizeof(arr[0]) / sizeof(arr[0][0]));
  // (1차원 배열 한 개의 크기) / (배열 안의 한 요소의 크기) --> 총 열의 개수 = 3

  printf("총 행의 개수 : %d \n", sizeof(arr) / sizeof(arr[0]));
  // (배열의 크기 ) / (1차원 배열 한 개의 크기) --> 총 행의 개수 = 2
}
```
- 코드 출처: https://modoocode.com/25

여기서, 당연하게도 `int arr[2][3]`은 `int [2][3]` 자료형의 배열이고, 총 6개의 원소들은 전부 `int` 자료형이므로 각 행의 첫 원소를 가리키는 `arr[0]`, `arr[1]`은 모두 암묵적으로 `int *`형으로 변환될 것이다.

그렇다면, `arr[0]`과 `arr[1]`을 모두 포함하여 `arr` 그 자체는 어떻게 가리킬 수 있을까? 여기서 우리가 실컷 논의한 **배열 포인터**와 이중 포인터가 등장한다.

우선 위의 질문, <u>`arr[0]`과 `arr[1]`을 모두 포함하여 `arr` 그 자체는 어떻게 가리킬 수 있을까?</u>에 대해 "`int**`로 바로 가리키면 되잖아" 라고 생각한다면, 안타깝게도 틀렸다. 위의 ` int arr[2][3]`을 예시로 생각해 보자:

```cpp
int main() {
  int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};
  int **pa = arr;

  printf("pa[1][1] : %d \n", pa[1][1]);
}
```
배열 `arr`의 첫 번째 원소를 가리키는 이중 포인터 `pa`를 선언해 보았다. 그러면 바로 접근할 수 있을까? 포인터 `pa`가 `arr`배열의 `[0][[0]` 위치를 정확히 가리키기 위해서는 다음 과정을 거쳐야 한다:
- `arr[1][1]` = * ( * (`arr` + 1 * `한 행의 크기`) + 1 * (`행 내부 원소의 크기`) )

우리는 행 내부 원소의 크기는 알고 있다. `arr[1][1]` 은 `int arr[2][3]` 배열의 한 원소이므로, 당연히 `int`형, 즉 4바이트다. 그러면:
- `arr[1][1]` = * ( * (`arr` + 1 * `한 행의 크기`) + 1 * 4 )

다음과 같이 정리할 수 있다. 그러나, 우리는 여전히 **한 행의 크기**를 모른다. 우리는 당연히 `[3]`, 즉 원소 4개가 모여 한 행을 이룬다는 것을 알고 있지만, 포인터 `pa`는 이것을 모른다! 

앞서 포인터를 정의할 때에는 포인터가 접근할 주소와 접근할 크기를 알려주어야 한다고 했다. **접근할 주소는 대입 연산자로 할당**하고, **접근할 크기는 포인터 선언 시 포인터의 자료형으로 넘겨준다**고 말이다.`int **pa = arr;`라는 아까의 선언을 보자. 접근할 주소는 arr, 즉 `arr[0]` (= `arr[0][0]`)을 가리키고 있다. 그리고 `pa`의 자료형은? `int (*)*`다. 즉 "`int *`형을 가리키는 포인터"이다. 그러면 이 자료형으로 접근할 수 있는 크기는? **포인터이므로 8바이트다.** 

그래서 정확히 포인터에게 한 행의 크기인 [3]을 알려주기 위해 `pa`는 `int (*)[3]` 자료형이 되어야 한다. 그러면 4칸을 한 행으로 갖는 배열(`[3]`)이고, 각 칸은 4바이트(`int`)라는 것을 포인터가 정확히 알 수 있다.

<br/>

> 🤔 **`arr [2][3]`인데 왜 `int (*)[2][3]` 자료형이 아닌 `int (*)[3]` 자료형인가요?**<br/><br/>✅ 우리가 1차원 배열, 예를 들어 `int arr[10];`이라는 배열에 포인터로 접근하던 때를 생각해보자. 이 때 포인터는 `int *` 자료형이었지, `int (*)[10]` 자료형이 아니었다. 즉 이 말은 원소가 10개이든, 100개이든 그건 중요하지 않고, <u>포인터 연산</u> 즉 **`pa + {정수}` 를 통해 포인터가 뛰어넘어야 할 바이트**만 포인터에게 알려주면 된다는 뜻이다.<br/>그러므로 `arr [2][3]`도 마찬가지로, `int [3]`짜리 배열이라는 사실은 각 원소의 크기와 각 행의 크기를 알려주므로 중요하지만, 그 배열이 총 3개(`[2]`)인지 몇 개인지는 중요하지 않다. 사실 포인터가 배열의 끝을 중요하게 생각하고 알 수 있었다면 **오버플로우** 문제를 지금보다 덜 신경써도 됐을 것이다...

<br/>

## 심화: 자료형과 포인터
개인적으로 헷갈리는 부분을 정리했다.

```cpp
int main() {
  int arr[3] = {1, 2, 3};
  int (*pa)[3] = &arr;
  int (*pa)[3] = arr; // 에러!

  int newarr[2][3] = {{1, 2, 3}, {4, 5, 6}};
  int (*newpa)[3] = arr;
  int (*newpa)[3] = &arr; // 에러!
}
```
똑같은 `int (*)[3]` 포인터 `pa`와 `newpa`인데, 1차원 배열을 가리킬 때는 `&`을 붙여야 하고 2차원 배열을 가리킬 때는 반대로 `&`을 붙이면 에러가 난다. 어째서?

여기서 다시 한번 **배열의 주소값**과 **배열 이름**의 차이를 명확히 정리하고 넘어가려고 한다.
- **배열의 주소값**은 배열 그 자체를 가리키는 주소다.
- **배열 이름**은 배열의 첫 번째 원소의 주소다.

```cpp
  int arr[10];

  printf("배열의 주소값: %p", &arr);
  printf("배열의 첫 번째 원소의 주소값: %p", arr); // 배열의 주소값과 동일하다
```
위와 같이 `int` 원소 10개짜리, 즉 40바이트짜리 배열 `arr`가 있다고 하자. 그러면 당연히 배열의 주소값과 배열의 첫 번째 원소의 주소값은 **동일**하다. 주소값이란 어떤 데이터의 **시작 위치**이기 때문이다. 그러나 포인터에 할당될 때에 이 둘은 완전히 다르다. `&arr`으로 할당하면 배열의 전체 크기, 즉 40바이트만큼 가리키는 `int (*)[10]` 자료형을 넘겨주게 되고, `arr`으로 할당하면 첫 번째 원소의 크기, 즉 4바이트만큼 가리키는 `int *`자료형을 넘겨주게 된다.

따라서 다시, 위의 코드에서
```cpp
int arr[3] = {1, 2, 3};
int (*pa)[3] = &arr;
int (*pa)[3] = arr; // 에러!
```
부분은 포인터의 자료형에 맞추어 `&arr`, 즉 배열 전체를 넘겨주어야 한다. `int (*pa)[3] = arr;`의 경우 `int (*)[3]` 자료형인 포인터에 `int *` 자료형인 `arr`을 넘겨주는 꼴이 되어 `incompatible pointer types` 에러를 발생시킨다. 이후 원소에 접근할 때에도 `(*pa)[1]`과 같이 포인터의 값, 즉 *배열에 접근하여 원소를 불러와야 한다* (`(*pa)`는 그 `pa`의 값을 역참조한다는 뜻으로 `arr`과 같다. 최초 선언 시의 `(*pa)`는 `배열 포인터 pa`라는 뜻이므로, 단순히 포인터로 사용하기 위해서는 그냥 `pa`라고 사용하며, `(*pa)`는 그 `pa`의 값을 역참조한다는 뜻으로 값, 즉 배열 자체에 접근한다). **그러니까 사실 1차원 배열에서 `(*pa)`같은 배열 포인터는 굳이 필요하지 않다.**

```cpp
int newarr[2][3] = {{1, 2, 3}, {4, 5, 6}};
int (*newpa)[3] = newarr;
int (*newpa)[3] = &newarr; // 에러!
```
반면, 위의 코드는 어떨까. 2차원 배열이므로 우선 배열 전체의 주소를 의미하는 `&arr`의 자료형이 `int (*)[2][3]`이라는 것은 알겠다. 그렇다면, `arr`는? 이 배열의 첫 번째 원소는 `arr[0]`일까, `arr[0][0]`일까? `newarr`는 **배열을 원소로 갖는 배열**이다. 정확히 말하자면 "1차원 원소 두 개를 원소로 갖는 2차원 배열"이다. 그러므로 이 배열의 첫 번째 원소는 `arr[0]`이다. 물론 `arr[0][0]`과 시작 주소는 같다. 하지만 `arr[0]`의 자료형은 `int (*)[3]`이고 `arr[0][0]`의 자료형은 `int *`이다. 그래서 `newarr`의 한 원소, 즉 한 1차원 배열을 가리키려면 `int (*newpa)[3] = arr;`이 맞다.

<br/>

## 🙌 진짜 마무리
'배열 포인터'란, 포인터를 통해 배열을 인덱싱하는 것과 동일한 일을 하기 위해 만들어졌다고 했다. 즉, `{배열 포인터}[1]`은 `{배열}[1]`과 같았으면 좋겠다는 이야기다. 

그러니까 위의 코드에서 `int newarr[2][3] = {{1, 2, 3}, {4, 5, 6}};`에 포인터 `newpa`로 접근한다는 것은, `newarr[1][1]`과 `newpa[1][1]`이 같아야 한다는 이야기다.

즉 `newpa`는 배열 `newarr`를 가리켜야 하는 것은 맞는데, 배열 전체가 아닌 각 원소(1차원 배열)의 크기만큼을 가리키도록 해서 그 내부에도 다시한번 인덱스로 접근할 수 있는... 뭐 그런 것이다.

```cpp
int zippo[4][2];

Expression    Type            Implicitly converted to  Equivalent expression
----------    ----            -----------------------  ---------------------
zippo         int [4][2]      int (*)[2]               
&zippo        int (*)[4][2]       
*zippo        int [2]         int *                    zippo[0]
zippo[i]      int [2]         int *
&zippo[i]     int (*)[2]                               
*zippo[i]     int                                      zippo[i][0]
zippo[i][j]   int
&zippo[i][j]  int *
*zippo[i][j]  invalid

```
끝끝내 이해가 안된다면 우선 외우고 차차 생각해보는 것도 방법이다!

<br/>

### 👍 진짜 마지막으로 계산
```cpp
int newarr[2][3] = {{1, 2, 3}, {4, 5, 6}};
int (*newpa)[3] = newarr;

newpa[1][1];
(*newpa)[1][1];
```
- `newpa[1][1]` = `(newpa[1])[1]` 
- `newpa`는 `int(*)[3]` 자료형이므로 `(newpa[1])[1]` = `(newpa + 1 * (int [3]))[1]`
- `newpa[1]` = `{1, 2, 3}`이므로 `&{1, 2, 3}[0]` 즉 `newpa[1]`는 `int *` 자료형
- `(newpa[1])[1]` = `(newpa + 1 * (int [3])) + (1 * int)`
- `(newpa + (1 * int [3]))` = `(newpa + 12)`
- `(newpa + 1 * (int [3]))[1]` = `(newpa + 12) + (1 * int)`
- `(newpa + 12) + (1 * int)` = `(newpa + 12) +  (1 * 4)` = `newpa + 16`
- 따라서 `newpa[1][1]` = `*(&newarr[0] + 16)`
- `*(&newarr[0] + 16)` = `5` = `newarr[1][1]`

- `(*newpa)[1][1]` = `((*newpa)[1])[1]`
- `(*newpa)`는 `newarr[0]`의 내용에 바로 접근 = `{1, 2, 3}`
- `(*newpa)[1]`은 {1, 2, 3}[1] = `2`
- 따라서 `(*newpa)[1][1]`은 존재하지 않는 원소.

정신나갈것같아~ 일단 포인터는 여기까지만;;

```toc
```
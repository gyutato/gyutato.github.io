---
emoji: 🌱
title: C 포인터 벼락치기 (4) 이중 포인터와 배열 포인터
date: '2022-04-05 23:08:12'
author: 규자
tags: Basics C
categories: Basics C 42Seoul
---

## ⭐️ 포인터 정리하기 ⭐️

이틀만에 꽤나 많은 내용을 머릿속에 집어넣었다. 인풋이 많으면 반드시 꼬이는 법이라, 잠깐 포인터의 핵심들을 직관적으로 짚어보고 넘어가려고 한다.

```cpp
#include <stdio.h>

int a = 10;
int arr[5] = {1, 2, 3, 4, 5};
int *p = &a;
int *parr = arr;
```

자, 코드를 보면서 천천히 되짚어보자.

1. 포인터는 특정 변수의 메모리 상 **주소값** 을 담고 있다.
2. 포인터는 변수다. 가리키는 주소는 변경될 수 있다.
3. 포인터는 가리킬 변수의 자료형 및 참조 연산자 `*`를 결합하여 만든다: `int *p;`
4. *변수명을 떼어내면 변수의 형태를 알 수 있다.* `p`는 `int *`형 변수라고 생각하자.
5. 배열은 원소들의 집합이다. 이 원소들은 메모리 상에 **연속적으로** 위치한다.
6. **배열 이름은 첫 번째 원소의 주소를 가리키는 포인터로 타입 변환된다.** 단, `sizeof`나 `&` 연산자가 쓰인 경우는 예외다.
7. **이 때 배열 이름은 포인터 '상수'로 변환된다.** 즉, `++`이나 `--`, `+=` 등으로 원본을 변경할 수 없다.
8. `arr[i]`와 같이, 배열 이름 뒤에 `[]` 연산자가 사용될 경우 컴파일러는 이를 `*(arr + i)`로 변환한다. 
    - 이 때 `+` 연산자의 변환 규칙에 따라 i는 사실 `(배열에 담긴 원소 타입의 크기 * i)`이다.

<br/>

## 이중 포인터, 포인터의 포인터
> 여기서부터는 `*`이 두 개씩 붙은 변수가 튀어나온다. 헷갈릴 수 있으므로 위의 4번, *변수명을 떼어내면 변수의 형태를 알 수 있다* 는 점을 기억하자.

자 그럼, 이번에는 **포인터를 가리키는 포인터**에 대해 생각해보자.
```cpp
#include <stdio.h>

int a = 10;
int *pa = &a;
int **ppa = &pa;

printf("변수 a의 값은:  %d, 주소는 : %p\n", a, &a);
printf("변수 pa의 값은 : %p, 주소는 : %p\n", pa, &pa);
printf("변수 ppa의 값은 : %p, 주소는 : %p\n", ppa, &ppa);

printf("변수 a의 값은:  %d\n", a);
printf("포인터 pa가 가리키는 주소의 실제 값은 : %d\n", *pa)
printf("포인터 ppa가 가리키는 주소의 실제 값은: %p\n", *ppa);
printf("이중 포인터 ppa가 가리키는 주소의 최종 값은: %p\n", **ppa);
```
이 코드를 잘 생각해 보길 바란다. 먼저, 위의 세 `printf`문에서 변수 a의 주소를 포인터 pa가 담고 있고, 그 포인터 pa의 주소를 포인터 ppa가 담고 있음을 확인할 수 있을 것이다. 

당연하게도, 포인터도 변수이므로 메모리 어딘가에 주소를 부여받고 공간이 있어야 한다!

다만 헷갈리는 건 아래 네 줄의 `printf`문이다. 그 전에, 이중 포인터의 형태를 다시 한 번만 생각해 보자.
```cpp
int **ppa = &pa;
int* *ppa = &pa;
```
위의 두 코드는 완전히 같은 코드다. 뭐 당연하다. 바보같을 수 있지만 나는 왜 `*` 연산자가 변수명 바로 앞에 나란히 붙어 있는지가 엄청나게 신경쓰여서 진도를 못 나갔다. 두 연산자가 나란히 붙어 있다고 다른 의미가 되는 게 아니라, **변수명 바로 앞의 `*` 연산자**는 해당 변수가 포인터임을 지정하는 역할을 하고, 그 앞의 나머지 `*`들은 몇 개가 되었든 해당 포인터가 가리킬 자료형을 뜻한다. 

즉, 포인터 `ppa`는 `int *` 자료형을 가리키는 포인터라는 뜻이다.

이를 조금 더 잘 이해하기 위해서는 별 거 아니지만 `*`연산자가 **오른쪽 우선** 연산자라는 점을 기억하자. 이따 2차원 배열의 `[]` 연산자에서 헷갈릴 수 있어 미리 말하자면 `[]` 연산자는 **왼쪽 우선** 연산자다.

```cpp
printf("변수 a의 값은:  %d\n", a);
printf("포인터 pa가 가리키는 주소의 실제 값은 : %d\n", *pa)
printf("포인터 ppa가 가리키는 주소의 실제 값은: %p\n", *ppa);
printf("이중 포인터 ppa가 가리키는 주소의 최종 값은: %p\n", **ppa);
```
그렇다면 다시 이 네 줄의 코드로 돌아오자. 우선 `pa`가 `a`를 가리키고 있으므로, `a`와 `*pa`는 같은 값이다. 

한편, 앞서 말했듯 `ppa`는 `int *`자료형, 즉 포인터 `pa`를 가리키므로 `*ppa`는 `pa`의 값인 **`a`의 주소**다. 그렇기 때문에 `**ppa`는 `*(a의 주소)`, 즉 `*pa`가 되어 위와 같이 a의 값을 나타내게 된다.

<br/>

## 배열의 포인터
여길 생각해보기 전에 아래 코드의 다섯 변수의 자료형을 정확히 알고 있는지 생각해보자:

```cpp
char a; // char형, 1바이트
int b; // int형, 4바이트
double c; // double형, 8바이트

char d[10]; // char [10]형, 10바이트
int e[5][10]; // int [5][10]형, 200바이트
```
- 코드 출처: https://www.acmicpc.net/blog/view/32

d, e를 보면, 뭔가 자료형이 이상하다. 그냥 char형, double형의 배열이 아닌 걸까?

**아니다.** 배열 또한 별개의 자료형이다. 그리고 배열의 크기가 다르면 다른 배열, 다른 자료형이다.

예를 들어 char [10] 자료형과 char [11] 자료형은 엄연히 다른 자료형이다. 전자는 10바이트 크기의 자료형이고, 후자는 11바이트 크기의 자료형이다.

물론 크기가 같아도 적힌 숫자가 다르면 다른 자료형이다. (ex, char [5][10], char [10][5])

<br/>

그럼 이제 배열의 포인터에 대한 이야기를 해보자.

앞서 말했듯 배열도 별개의 자료형이기 때문에, 배열을 위한 포인터가 존재한다. 그 말인즉슨, `int a[10]` 이라는 변수를 보고 **"int 자료형을 가리키는 포인터 `int *p`를 사용하면 되겠다!"** 와는 다른 이야기를 지금부터 하겠다는 뜻이다.
```cpp
int a[10];

int *p; // int 변수를 위한 포인터
int (*pa)[10]; // int[10] 변수를 위한 포인터
```
여기서 a의 자료형은 `int`라고 생각하면 안된다! 이 때의 자료형은 `int[10]`이며, 크기는 **40바이트**다.

**아니, 앞에서는 그렇게 안했잖아요? 🤔**

<br/>

### 배열의 주소와, 배열의 '첫 번째' 주소
그렇다. 우리는 지금까지 아래와 같이 `int` 형 배열을 `int` 포인터로 잘 가리켜 왔다:
```cpp
int a[10];

int *p = a; // int 자료형의 포인터 변수 p
p[3] = 3; // a[3] = 3;

int (*p)[10] = &a; // int [10] 자료형의 포인터 변수 p. p의 자료형은 int (*)[10]
(*p)[3] = 3; // a[3] = 3;
```
사실 포인터 `p`와 `pa` 둘 다 위의 코드를 보면 결과적으로 `a[3] = 3`과 같다는 점에서 거의 비슷하다고 볼 수 있다. 하지만 엄밀하게 말하면 **포인터 `p`의 경우, 배열의 주소를 포인터 변수로 담은 것이 아니다. 오직 `a[0]`의 주소만 포인터로 담은 것이다.**

우리는 앞에서 `[]` 연산자의 역할을 보았다. `arr[i]`는 컴파일러에 의해 `*(arr + i)`로 변환된다고 말이다. 마찬가지로, `a[0]`은 `*(a + 0)`으로 변환된다. 즉 포인터 자료형이다. 정리하자면 
a라는 배열 자체는 `int [10]` 자료형이지만 a[0]은 `*(a + 0)`이고, 이는 `int *` 자료형이다.

그럼 변수 `p`에는 오직 배열 `a`의 첫 번째 원소의 주소만 담긴 건데, 어떻게 `p[3]`과 같이 배열에 접근할 수 있는 걸까? 전혀 어렵게 생각할 것 없다. 바로 위에서 말했듯 `arr[i]`는 컴파일러에 의해 `*(arr + i)`로 변환된다. 따라서 `p[3]`은 `*(p + 3)`이고, 이를 풀어 적으면 `*(a[0] + 3)`이 된다. 다시 이것은 `*(*(a + 0) + 3)`이 된다. 

이 때 a라는 배열 자체는 `int [10]` 자료형이라고 해서 배열 이름 `a`가 `int [10]` 자료형이라고 헷갈려서는 안 된다. 우리는 앞에서 분명히 **배열 이름은 배열의 첫 번째 원소의 주소를 가리키는 포인터 상수로 변환된다**고 이야기했다. 그러니까 `int *p = a;`와 같이 `int *` 자료형의 포인터 p에 a를 대입할 수 있는 것이다. 이는 곧 `a[0]`의 주소를 대입한 것과 같으니까. 

<br/>

### 베열의 '주소'를 포인터에 넣자!

자, 돌고돌아 이 이야기의 핵심은 결국 `&a`를 포인터에 넣고자 할 때는 자료형을 다르게 생각해야 한다는 것이다.  배열 이름 `a`가 아니라, 배열 자체의 주소인 `&a`가 바로 우리가 이야기해볼 대상이다.

앞서 우리는 포인터 변수는 **접근할 주소**와, **접근할 크기**를 알아야 한다고 이야기했다.접근할 주소는 포인터 변수의 값이 되고, 접근할 크기는 사용하고자 하는 자료형의 크기가 된다. 예를 들어 `int`형 포인터라면 접근할 크기는 `int`형의 크기인 4바이트가 될 것이다.

그러면, 내가 '배열의 <u>첫 번째 원소</u>의 주소'가 아니라, **배열 그 자체**의 주소를 포인터에 넣고 싶으면 자료형의 크기를 얼마로 지정해야 할까?
```cpp
int a[10]; // int [10] 자료형 변수 a. 크기는 40 바이트
int (*p)[10] = &a; // int [10] 자료형의 포인터 변수 p. p의 자료형은 int (*)[10]
int *pa = a;

int arrSize = sizeof(a); 
int ptrSize = sizeof((*p)); 
int wrngSize = sizeof(pa);

printf("%d", arrSize); // 40
printf("%d", ptrSize); // 40
printf("%d", wrngSize); // 8
```
- 코드 참고: https://www.acmicpc.net/blog/view/32

위의 코드를 보자. `a`가 아닌 `&a`를 담기 위해, `*p`가 아닌 `(*p)`가 쓰였다. 

앞서 말했듯 **포인터 변수가 접근할 크기는 사용하고자 하는 자료형의 크기**다. 배열 `a`자체는 40바이트(4 byte * 10)의 정보를 담을 수 있는 `int [10]` 형의 변수이므로, 배열 `a`의 주소를 담은 포인터 `p`가 접근할 크기 역시 40바이트여야 한다. 위의 코드에서 `sizeof`를 통해 확인해보니, 배열의 크기를 정확히 담고 있는 포인터는 `(*p)`, 즉 괄호로 감싸준 포인터임을 알 수 있다. 이처럼 `(*{변수명})` 형태로 사용되는 포인터는 **배열 포인터**라고 한다.

그럼 다음 글에서 이 배열 포인터가 왜 필요한지 조금 더 자세히 이야기해보도록 하자.

```toc
```
{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"d026fe1d-c523-541c-9950-1c536f008a8d","excerpt":"🤷‍♀️ 배열 포인터는 왜 필요한가? 앞서 우리는 배열 이름, 즉 배열의 첫 번째 원소의 주소가 아니라 배열 자체의 주소를 담기 위한 포인터를 생각해보았다. 왜 굳이 이런 포인터가 필요할까? 애초에 베열의 이름이 포인터와 유사한 기능을 (사실 포인터가 맞지만, 그 값을 변경할 수 없는 상수라는 점에서 차이가 있다) 하는데 왜 따로 배열 포인터를 정의하여 사용하는 것일까. 이는 2차원 이상의 배열을 가리킬 때 포인터를 통해 배열과 같이 인덱싱()을 할 수 있도록 하기 위함이다. 한 마디로, 포인터를 배열처럼 사용하기 위해서 배열 포인터를 정의하여 사용한다. 1. 2차원 배열? 2차원 배열을 생각해 보자. 위 경우  짜리 배열 2 개가 메모리에 연속적으로 존재하는 것이다. 여기서 를 사용하여 2차원 배열의 열, 행의 개수를 계산할 수 있다: 코드 출처: https://modoocode.com/25 여기서, 당연하게도 은  자료형의 배열이고, 총 6개의 원소들은 전부  자료형이므로 각 행의 …","frontmatter":{"categories":"C 42Seoul","title":"(C) 포인터 벼락치기 5. 포인터와 배열의 자료형","date":"April 06, 2022"},"fields":{"slug":"/c-pointer-cram-5/"}}},{"node":{"id":"82e36ea1-21ab-5a64-9cca-696a305ebfd2","excerpt":"⭐️ 포인터 정리하기 ⭐️ 이틀만에 꽤나 많은 내용을 머릿속에 집어넣었다. 인풋이 많으면 반드시 꼬이는 법이라, 잠깐 포인터의 핵심들을 직관적으로 짚어보고 넘어가려고 한다. 자, 코드를 보면서 천천히 되짚어보자. 포인터는 특정 변수의 메모리 상 주소값 을 담고 있다. 포인터는 변수다. 가리키는 주소는 변경될 수 있다. 포인터는 가리킬 변수의 자료형 및 참조 연산자 를 결합하여 만든다:  변수명을 떼어내면 변수의 형태를 알 수 있다. 는 형 변수라고 생각하자. 배열은 원소들의 집합이다. 이 원소들은 메모리 상에 연속적으로 위치한다. 배열 이름은 첫 번째 원소의 주소를 가리키는 포인터로 타입 변환된다. 단, 나  연산자가 쓰인 경우는 예외다. 이 때 배열 이름은 포인터 ‘상수’로 변환된다. 즉, 이나 ,  등으로 원본을 변경할 수 없다. 와 같이, 배열 이름 뒤에  연산자가 사용될 경우 컴파일러는 이를 로 변환한다. 이 때  연산자의 변환 규칙에 따라 i는 사실 이다. 🪄 이중 포인터, …","frontmatter":{"categories":"C 42Seoul","title":"(C) 포인터 벼락치기 4. 이중 포인터와 배열 포인터","date":"April 05, 2022"},"fields":{"slug":"/c-pointer-cram-4/"}}},{"node":{"id":"834712e6-3610-5a06-a14a-29dde5cb2c06","excerpt":"⭐️ 배열과 포인터 ⭐️ 개인적으로 여태 C언어를 공부하면서 가장 어려웠던 부분이지만, 타 언어에 비해 C언어 공부가 더욱 흥미로운 이유이기도 했던 배열과 포인터의 관계를 이야기해보자. 먼저, 배열에 대한 기억을 되짚어 보자. 배열이란 간단히 다음과 같았다: 변수가 여러개 모인 것 메모리 상에 연속되게 놓여 있는 원소(변수)들의 집합에 이름붙인 것 여기서 2차원, 3차원 등 고차원 배열도 만들 수 있었지만 결국 이것들도 메모리 상에서는 1차원 평면 위에 연속되게 놓여 있는 형태가 된다. 코드 출처: 모두의 코드 씹어먹는 C 언어(https://modoocode.com/24) 위 코드를 컴파일해보면, arr[0]부터 arr[9]까지 각 원소들의 주소값이 4씩 증가하며 연속적으로 위치하고 있음을 확인할 수 있다. 연속적이라고? 바로 앞에서 우리는 포인터에 + 1을 해주면 (ex. ) 그 다음 값에 접근할 수 있음을 확인했다. 그 말인 즉슨, 배열의 첫 번째 원소의 주소값을 포인터에 넣어 …","frontmatter":{"categories":"C 42Seoul","title":"(C) 포인터 벼락치기 3. 포인터와 배열","date":"April 05, 2022"},"fields":{"slug":"/c-pointer-cram-3/"}}},{"node":{"id":"5eb13f75-7308-5000-a9e9-709c0754d441","excerpt":"🧬 포인터의 타입 앞에서 우리는 포인터가 메모리 상에서 특정 데이터가 위치해있는 주소를 담고 있다는 사실을 알아보았다. 이 메모리의 주소는 각 ‘방’들을 구분하기 위해 각각의 ‘방’에 부여되어 있다고 했다. 그런데 이 ‘방’ 들은 일반적으로 각 1바이트이고, 각 자료형은 를 제외하고 대부분 2바이트 이상이다. 대표적으로 int 자료형은 4바이트 아닌가. 그렇다는 건 4개의 ‘방’을 차지하고 있다는 건데, 그 중 포인터는 어느 방을 가리키고 있는 것이며, 어디까지 한 개의 데이터로 인식할 수 있는 것일까? 여기서 포인터의 ‘타입’과 관련된 문제가 발생한다. 각 자료형이 차지할 수 있는 바이트의 크기를 명시하여 포인터에도 동일한 타입을 부여해주지 않으면, 메모리에서 얼마만큼을 읽어들여야 할 지 알 수 없게 된다. 왜냐하면 포인터에게 전달되는 주소값은 해당 변수(데이터)가 메모리에서 차지하는 모든 주소들의 위치가 들어있는 것이 아니라 시작 주소만 들어가 있기 때문이다! 1. 포인터와 변…","frontmatter":{"categories":"C 42Seoul","title":"(C) 포인터 벼락치기 2. 포인터의 타입과 상수 포인터","date":"April 04, 2022"},"fields":{"slug":"/c-pointer-cram-2/"}}},{"node":{"id":"a2fcb012-9e17-5b8e-a2d1-bc3121be7652","excerpt":"🔄 타입 캐스팅 (형 변환) 가끔씩 프로그래밍을 하다 보면 형이 다른 변수 끼리 대입을 하는 연산을 필요로 한다. 예를 들어서  형 변수의 값을  형 변수에 대입하거나,  형 변수에  형 변수의 값을 대입하는 경우다. 하지만 형이 다른 변수 끼리의 대입이나 연산은 컴파일이 불가능하거나, warning을 띄우게 된다.  형 변수에  형 변수를 대입하면 소수 부분이 잘려서 정수 부분만 들어간다. 컴파일러는 이에 따른 데이터 손실에 대한 warning을 띄운다 (error가 아니기에 컴파일은 된다). 여기서는 컴파일러가 암묵적으로 형 변환을 해주었지만, 다른 사람에게 이 코드를 보여준다고 생각하면 명시적으로 형 변환을 밝혀 주는 것이 좋겠다. 의 자료형은 로 선언되어 있으므로 의 앞에 를 붙여 형 변환 시킨 값을 에 넣어주겠다는 뜻이다. 형 변환 자체가 어려운 개념은 아니지만, 어쨌든 내가 선언한 변수가 컴파일 과정에서 다른 타입으로 변환되어 계산될 수 있다는 사실을 인지하는 것은 중요…","frontmatter":{"categories":"C 42Seoul","title":"(C) 포인터 벼락치기 1. 형 변환과 포인터","date":"April 04, 2022"},"fields":{"slug":"/c-pointer-cram-1/"}}},{"node":{"id":"4b1e4671-5f1e-5914-935d-33cc5753999c","excerpt":"📌 , ,  등 코드의 재활용성을 높이는 키워드를 통해 vanilla CSS보다 훨씬 간결한 스타일 코드를 작성해 보자. 🔁 반복문 1.  반복문을 사용하면  등 연속되는 여러 요소에 동일한 속성을 빠르게 적용할 수 있다. , ,  등의 키워드와 함께 사용하며, 보간법을 사용할 수 있어 유용하다. 다만, 자바스크립트의 보간법은 이었다면 SCSS에서는 으로 사용해야 한다. SCSS에서 는 이미 변수를 만드는 용도로 사용되고 있기 때문이다. 2.  SCSS는 JS의 배열과 유사한 , 객체와 유사한 이라는 데이터 종류를 지원한다. 의 경우 SCSS에서 취급할 수 있는 기본적인 데이터를 순서대로 명시한 데이터이며, 의 경우 key-value 형태로 데이터를 취급할 수 있으며 순서(인덱스)가 없다. 이러한 데이터들에 대해  키워드를 사용하면, 그 요소들을 반복적으로 순회할 수 있다. 🛠 함수 1.  여타 언어의 함수와 다를 것 없이, 파라미터를 받아 결과값을 연산해낸 후 이를 반환한다. 속…","frontmatter":{"categories":"frontend","title":"(SCSS) 반복문, 함수 그리고 재활용","date":"January 04, 2022"},"fields":{"slug":"/SCSS-grammar/"}}},{"node":{"id":"11e752b2-7b1b-507e-824e-be4cb794f666","excerpt":"🤔 TypeScript란? 마이크로소프트에서 구현한 JavaScript의 슈퍼셋(Superset) 프로그래밍 언어. 확장자로는 .ts를 사용하며, 컴파일의 결과물로 JavaScript 코드를 출력한다. 최종적으로 런타임에서는 이렇게 출력된 JavaScript 코드를 구동시키게 된다. 🤦‍♀️ 그게 무슨 소린가요? 타입스크립트는 한마디로 자바스크립트를 기반으로 ‘타입’을 부여한 언어다.\n즉 자바스크립트의 확장판 개념의 언어로 먼저 자바스크립트에 대한 선수 지식이 필수적이다. 타입스크립트는 “컴파일의 결과물로 JavaScript 코드를 출력한다.”이는 브라우저에서 타입스크립트 파일을 실행하기 위해서는 plain JavaScript로 파일을 한 번 변환하는 과정이 필요하다는 뜻이며, 이것을 이라고 부른다. 다만 전통적인 컴파일 언어들과 비교했을 때에는 비교적 다른 점이 많아, 이라는 용어를 사용하기도 한다. 한편, 자바스크립트는 컴파일 또는 트랜스파일 언어가 아닌 인터프리터 언어다. Comp…","frontmatter":{"categories":"TypeScript frontend","title":"(TypeScript) 개념과 초기 실행","date":"December 31, 2021"},"fields":{"slug":"/typescript-concept/"}}},{"node":{"id":"82fc39eb-2211-5130-9375-04020316b2ab","excerpt":"정규표현식이란? ✅ 정규식 (Regular Expression) 문자열에서 특정 문자 조합을 찾기 위한 패턴이다. JavaScript에서는 정규 표현식도 객체로서, 의 와  메서드를 사용할 수 있다. 역할 문자 검색 (search) 문자 대체 (replace) 문자 추출 (extract) 📌 테스트 사이트:https://regexr.com/ 자바스크립트 정규식 생성 1. 생성자 함수 방식 2. 리터럴(Literal) 방식 메소드 메소드 문법 설명 test  일치 여부(Boolean) 반환 match  일치하는 문자의 배열 (Array) 반환 replace  일치하는 문자를 대체 플래그(옵션) 플래그 설명 g 문자열 전체에서 일치하는 모든 문자 (global) i 영어 대소문자 구분 없이 일치 (ignore case) m 여러 줄로 간주하여 탐색 (multi line) 패턴(표현) 패턴 설명 ^ab 줄(Line) 시작에 있는 ab와 일치 ab$ 줄(Line) 끝에 있는 ab와 일치 …","frontmatter":{"categories":"JavaScript frontend","title":"(JavaScript) 정규표현식 개념과 문법","date":"December 30, 2021"},"fields":{"slug":"/regexp-basics/"}}},{"node":{"id":"e6c1e061-db5c-5e94-a98b-148427505819","excerpt":"📌 Syntactically Awesome StyleSheets! 대규모 스타일시트를 잘 구조화하여 사용할 수 있도록 효율셩을 향상시켜준다. 1. CSS / Sass(Scss) 🤔 CSS 코드가 한 파일로 제작된다면? 가독성 저하: 어디서부터 어디까지 어떤 스타일을 담당하고 있는지 파악하기 어려움 (네스팅 불가) 중복 코드 혹은 레거시 코드를 생성하기 쉬움 단순 수정에도 전체 코드를 일일히 확인해야 함 프로젝트가 커질수록 단순 CSS로는 작업하는 속도가 느려짐 즉, Sass(Scss) 개발은 선택이 아닌 필수가 되어가고 있음 2. Sass(Scss) 7-1 패턴 💡 파일명에 가 붙는 경우 되어 사용될 것으로 파악   변수, 함수, 믹스인 등 추상화되어야 할 것들  전체 스타일 중 기본이 되는 것들  버튼, 드롭다운, 인풋 등 독립된 요소로 제어할 수 있는 것들  컴포넌트보다 큰 개념으로, 보다 넓은 섹션 (헤더, 푸터, 네비게이터 등)  한 사이트를 구성하는 각 페이지  다크, 라…","frontmatter":{"categories":"frontend","title":"(SaSS) 기본과 필요성 (CSS와의 차이)","date":"December 29, 2021"},"fields":{"slug":"/SaSS-concept/"}}},{"node":{"id":"858a039f-de02-53c6-b771-bc6155440481","excerpt":"1.  요소의 전환(시작과 끝) 효과를 지정하는 단축 속성 가상 선택자가 아닌 요소 원본을 제어하는 CSS 부분에 명시해주어야 함! ✅ 개별 속성 : 속성명 기본값: , 해당 요소의 모든 속성에 적용 속성이름을 명시하여 전환 효과를 사용할 속성 이름을 따로 명시할 수 있음 (ex. 다른 속성은 모두 제외하고 요소의 가로 너비에만 전환 효과가 들어갔으면 좋겠어!) : 타이밍함수 기본값: , 느리게-빠르게-느리게 , , ,  등  값을 사용하여 직접 제어할 수도 있음 (어려움) 📌 CSS easing functions cheat sheet, easing functions mdn📌 Tweenmax easing - greensock.com : 대기시간 기본값:  2.  요소의 변환 효과 ✅ 2차원 변환 함수 , ,  X축 또는 Y축 이동 px등의 단위를 사용해 값 입력  X축 및 Y축 방향 크기 제어 : 회전 , : X축 또는 Y축 기울임 ✅ 3차원 변환 함수 ,  X축 또는 Y축 회전 …","frontmatter":{"categories":"frontend","title":"(CSS) 속성 4. 트랜지션(transition)","date":"December 28, 2021"},"fields":{"slug":"/css-properties-4/"}}},{"node":{"id":"ac18bdee-0bf4-5e52-a553-48aec2b795a4","excerpt":"1. 플렉스(정렬) 컨테이너 1차원 레이아웃에서 수직 정렬을 수평 정렬로 전환 이 때 가 부여된 부모 요소를 플렉스 컨테이너라고 할 수 있다. 해당 컨테이너 안에서 수평으로 정렬되는 자식(하위) 요소들을 플렉스 아이템이라고 할 수 있다. 플렉스 컨테이너와 아이템 각각에 부여할 수 있는 속성이 일부 다르다. ✅ 플렉스 컨테이너 사용가능 속성  플렉스 컨테이너 (flex container)의 화면 출력 특성 : 블록 요소와 같이 flex container 정의 아이템 요소 중 최대 높이에 맞추어 높이는 줄어들지만, 뷰포트 너비에 맞추어 컨테이너 너비는 최대한으로 늘어남 : 인라인 요소와 같이 flex container 정의 컨테이너의 높이와 너비 모두 아이템 요소들에 맞추어 최대한 줄어들게 됨  : 행(수평)을 축으로 정렬 (=수평 정렬), 왼쪽에서 오른쪽 : 오른쪽에서 왼쪽으로 수평 정렬 , 를 통해 수직 정렬도 가능하지만, 요소 간 정렬의 기본값이 수직 정렬이므로 굳이 설정해야 하…","frontmatter":{"categories":"frontend","title":"(CSS) 속성 3. 플렉스(flex)","date":"December 27, 2021"},"fields":{"slug":"/css-properties-3/"}}},{"node":{"id":"67e427e2-32ef-5961-bfdb-73d22eb23059","excerpt":"1. 문자 제어  기본값: rgb(0,0,0) 기타 지정 가능한 색상  기본값: 왼쪽 정렬 () 오른쪽 정렬(), 가운데 정렬() 가능  기본값:   태그의 경우, 기본적으로  값을 가지고 있음 밑줄 , 중앙(취소)선  등  들여쓰기(양수) 및 내어쓰기(음수) 기본값:  2. 배경 제어  해당 요소의 배경 색상 지정  이미지를 삽입하는 것이 아니라, 배경에 이미지를 깔게 되므로, 요소의 크기 이상으로 배경 이미지가 드러날 수 없음.  앞선 문제(요소의 크기 이상으로는 배경 출력이 불가)를 해결하기 위해, 요소의 크기에 맞게 배경 이미지의 크기를 제어할 수 있음  이미지가 요소보다 작을 경우, 반복되어 요소의 크기만큼 채울지 여부를 제어할 수 있음 기본값 : 이미지를 수직, 수평 반복 : 수평으로만 반복 : 수직으로만 반복 : 반복하지 않음  요소의 배경 이미지 위치 , , , ,  등 방향 또는 px, em, rem 등 단위로 지정  기본값: , 이미지의 실제 크기 px, em, …","frontmatter":{"categories":"frontend","title":"(CSS) 속성 2. 문자 및 배경 제어","date":"December 26, 2021"},"fields":{"slug":"/css-properties-2/"}}},{"node":{"id":"14c08c31-aca7-5c23-b5c2-b4273645a9bb","excerpt":"🙌 박스 모델, 글꼴, 문자, 배경, 배치, 플렉스(정렬), 전환, 변환, 띄움, 애니메이션, 그리드, 다단, 필터 등 속성 정리! 💡 코드로 작성되어 있는 속성을 보고 머릿속으로 어떻게 그려질 지 생각해보는 연습이 중요하다. 1. ,  기본값:  요소에 이미 들어있는 속성의 값 ㅡ 브라우저가 자동으로 요소의 너비를 계산 px, em, vw 등 단위로 지정 와 같은 블록 요소의 경우: : 부모 요소의 크기만큼 자동으로 늘어남 : 포함한 콘텐츠 크기만큼 자동으로 줄어듦 과 같은 블록 요소의 경우: : 포함한 콘텐츠 크기만큼 자동으로 줄어듦 : 포함한 콘텐츠 크기만큼 자동으로 줄어듦 ,  기본값:  px, em, vw 등 단위로 지정 ,  기본값:  px, em, vw 등 단위로 지정 위와 같이 자식 요소의 가 부모 요소의 보다 긴 경우, 부모 요소를 넘어 길어질 수 있다. (도 당연히 마찬가지) 2. ,  : 요소의 외부 여백(공간)을 지정하는 단축 속성 기본값:   지정 가능 세로…","frontmatter":{"categories":"frontend","title":"(CSS) 속성 1. property basics","date":"December 23, 2021"},"fields":{"slug":"/css-properties-1/"}}},{"node":{"id":"afd5423a-e175-53d8-8af5-33a34f67b4ee","excerpt":"1. 선택자{속성: 값;} 선택자: 스타일(CSS)를 적용할 대상 2. CSS 선언 방식 내장 방식: 의 내용으로 스타일을 작성하는 방식 인라인 방식: 요소의  속성에 직접 스타일을 작성하는 방식 (ex.  링크 방식: 로 외부 CSS 문서를 가져와서 연결하는 방식 (병렬 연결)  방식: CSS의  규칙으로 CSS 문서 안에서 또 다른 CSS 문서를 가져와 연결하는 방식 (ex.   ) 직렬 연결: 된 CSS는 가 작성된 해당 CSS가 HTML에 연결되기 전이나,  줄이 해석되기 전까지는 문서에 적용되지 않음 즉 적용이 지연되는데, 장점일수도 단점일수도 있음. 3. CSS 선택자 ✅ 기본 선택자 (애스터리스크): 기본, 전체 선택자. 모든 요소를 선택 단독으로는 쓸 일이 잘 없고, 복합 선택자를 통해 어떤 범위 안에 있는 모든 요소를 선택할 때 쓰일 수 있음. : 기본, 태그 선택자. 태그 이름이 ABC인 요소를 선택. (ex. ) : 기본, 클래스 선택자. HTML 클래스 속성의…","frontmatter":{"categories":"frontend","title":"(CSS) 기본 문법 (+ HTML 전역 속성)","date":"December 22, 2021"},"fields":{"slug":"/css-basics/"}}},{"node":{"id":"88d6e98c-3078-54ec-af14-07a09dc54bd3","excerpt":"1. 부모와 자식 요소 상위(조상), 하위(후손)요소는 각각 부모와 자식 요소를 포함하게 됨. 단 부모와 자식 요소는 바로 윗 요소 / 바로 아랫 요소 2. 글자와 상자 ✅ 글자 - 인라인()요소 요소가 수평으로 쌓임 (자체 높이나 넓이를 가지지 않고, 최대한 줄어들려고 함) 포함한 콘텐츠 크기만큼 자동으로 줄어들려고 함 가로세로 사이즈를 가질 수 없음 CSS로도 지정할 수 없음 여백의 경우 좌우는 가능하지만 상하 여백은 불가 하위 요소로 블록 요소를 가질 수 없음 ✅ 상자 - 블록(Block) 요소 요소가 수직으로 쌓임: 가로는 부모 요소의 크기만큼 자동으로 늘어남, 세로는 포함한 콘텐츠 크기만큼 자동으로 줄어들려고 함 단, 가로세로 사이즈를 CSS로 설정해 줌으로서 크기를 지정할 수 있음 하위 요소로 블록과 인라인 요소 모두 가질 수 있음 3. HTML 핵심 요소 정리 ✅ 블록 요소  : 특별한 의미가 없는 구분을 위한 요소  ~ : 제목을 명시하는 태그  :  너무 커서 저는…","frontmatter":{"categories":"frontend","title":"(HTML) 기본 개념과 태그","date":"December 21, 2021"},"fields":{"slug":"/html-basics/"}}}]},"site":{"siteMetadata":{"language":"ko","author":{"name":"이규원","bio":{"role":"개발자","description":["언제나 질문을 던지는","더 나은 가능성을 찾는","필요한 서비스를 만드는"],"thumbnail":"sample.png"},"social":{"github":"https://github.com/gyutato","linkedIn":"","email":"10014id@gmail.com"}}}}},"pageContext":{}}